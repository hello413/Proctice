<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601568 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="431"/>

<div>
<span><div><span style="background-color: rgb(255, 255, 255);"><span style="font-size: 24pt; color: rgb(255, 0, 0); font-family: 幼圆; font-weight: bold;">JDK1.6内存模型</span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font face="幼圆" style="font-size: 10pt;"><br/></font></span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-family: 幼圆;-evernote-highlight:true;"><img src="JMM（Java Memory Model）——Java内存模型_files/Image.png" type="image/png" data-filename="Image.png"/></span></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;">JDK1.7内存模型</span><br/></div><div><br/></div><div><span style="font-family: 幼圆;"><img src="JMM（Java Memory Model）——Java内存模型_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;">JDK1.8内存模型</span><br/></div><div><span style="background-color: rgb(255, 250, 165);font-size: 10pt;-evernote-highlight:true;"><br/></span></div><div><span style="font-family: 幼圆;"><img src="JMM（Java Memory Model）——Java内存模型_files/Image [2].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;">线程私有的内存区域</span><br/></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">程序计数器</span><br/></div><div><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">       </span></span></span></span></span></div><div><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    一块比较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。</span></span></span></span></span></div><div><span style="font-family: 幼圆; font-size: 14pt; min-height: 17pt;"><span style="color: rgb(54, 101, 238); font-weight: bold;"><br/></span></span></div><div><span style="font-family: 幼圆; font-size: 14pt; min-height: 17pt;"><span style="color: rgb(54, 101, 238); font-weight: bold;"><br/></span></span></div><div><span style="font-family: 幼圆; font-size: 14pt; min-height: 17pt;"><span style="color: rgb(54, 101, 238); font-weight: bold;">Java</span></span><span style="font-family: 幼圆; font-size: 14pt; min-height: 17pt;"><span style="color: rgb(54, 101, 238); font-weight: bold;">虚拟机栈</span></span><br/></div><div><br/></div><div><span style="min-height: 13pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数</span><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈和出栈</span><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">的过程。</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="min-height: 13pt; font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    之前我们一直讲的栈区域实际上就是此处的虚拟机栈，再详细一点，是虚拟机栈中的局部变量表部分。</span></span></span></span></span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 10pt;"><br/></span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    此区域一共会产生以下两种异常</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">:</span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">        1.</span> <span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">如果线程请求的栈深度大于虚拟机所允许的深度</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">(-Xss</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">设置栈容量</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">)</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">，将会抛出</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">StackOverFlowError</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">异常。</span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">        2.</span> <span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">虚拟机在动态扩展时无法申请到足够的内存，会抛出</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">OOM(OutOfMemoryError)</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">异常</span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">本地方法栈</span><br/></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;"><br/></span></div><div style="min-height: 15pt; text-align: left;"><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    本地方法栈与虚拟机栈的作用完全一样，他俩的区别无非是本地方法栈为虚拟机使用的</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">Native</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">方法服务，而虚拟机栈</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">为</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">JVM</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">执行的</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">Java</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">方法服务。</span></div><div style="min-height: 15pt; text-align: left;"><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div style="min-height: 15pt; text-align: left;"><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div style="min-height: 15pt; text-align: left;"><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;">线程共享区域</span><br/></div><div style="min-height: 15pt; text-align: left;"><span style="font-size: 14pt; min-height: 17pt; color: rgb(54, 101, 238); font-family: 幼圆; font-weight: bold;"><br/></span></div><div style="min-height: 15pt; text-align: left;"><span style="font-size: 14pt; min-height: 17pt; color: rgb(54, 101, 238); font-family: 幼圆; font-weight: bold;"><br/></span></div><div style="min-height: 15pt; text-align: left;"><span style="font-size: 14pt; min-height: 17pt; color: rgb(54, 101, 238); font-family: 幼圆; font-weight: bold;">Java</span><span style="font-size: 14pt; min-height: 17pt; color: rgb(54, 101, 238); font-family: 幼圆; font-weight: bold;">堆</span><br/></div><div><br/></div><div><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    在</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">JVM</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">启动时创建，</span><span style="min-height: 13pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">所有的对象实例以及数组都要在堆上分配。</span></div><div><span style="min-height: 13pt; font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">        </span></span></span></span></span></div><div><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    如果在堆中没有足够的内存完成实例分配并且堆也无法再拓展时，将会抛出</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">OOM。</span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">方法区/元数据区</span><br/></div><div><span style="min-height: 15pt; font-size: 12pt;"><br/></span></div><div><span style="min-height: 13pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    用于存储已被虚拟机加载的类信息、常量、静态变量、即时编</span><span style="font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">译器编译后的代码等数据。</span></div><div><span style="font-size: 10pt;"><br/></span></div><div><span style="min-height: 13pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">    此区域的内存回收主要是针对常量池的回收以及对类型的卸载。</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">当方法区无法满足内存分配需求时，将抛出</span><span style="min-height: 15pt; font-size: 10pt; color: rgb(51, 51, 51); font-family: 幼圆;">OOM异常。</span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">运行时常量池</span><br/></div><div><br/></div><div><span style="font-size: 10pt; font-family: 幼圆;">    编译期及运行期间产生的常量</span><span style="font-size: 10pt; font-family: 幼圆;">被放在运行时常量池中</span><span style="min-height: 15pt;"><span style="font-size: 10pt; font-family: 幼圆;">。</span></span></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: 幼圆; font-variant-caps: normal; font-variant-ligatures: normal;">    这里所说的常量包括：基本类型、包装类（包装类不管理浮点型，整形只会管理-128到127）和String。</span></span></span></span></span></span></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: 幼圆; font-variant-caps: normal; font-variant-ligatures: normal;">    类加载时，会查询字符串常量池，</span></span><span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 幼圆; font-variant-caps: normal; font-variant-ligatures: normal;">以保证运行时常量池所引用的字符串与字符串常量池中是一致的。</span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">直接内存</span><br/></div><div><br/></div><div><span style="font-family: 幼圆;">    在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</span></div><div><br/></div><div><span style="font-family: 幼圆;">    直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。也可能导致OutOfMemoryError异常出现。</span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(255, 0, 0); font-family: 幼圆; font-size: 24pt; font-weight: bold;">常量池的补充说明</span><br/></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">Class文件常量池</span><br/></div><div><br/></div><div><span style="font-family: 幼圆;">    Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">运行时常量池</span><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt;"><br/></span></div><div><span style="font-family: 幼圆;">    运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。</span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;"><br/></span></div><div><span style="color: rgb(54, 101, 238); font-family: 幼圆; font-size: 14pt; font-weight: bold;">字符串常量池</span><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt;"><br/></span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: 幼圆; font-variant-caps: normal; font-variant-ligatures: normal;">    存储字符串对象，或是字符串对象的引用。</span></span></span></span></span></div></span>
</div></body></html> 
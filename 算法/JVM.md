## JVM

##### 1. 先来讲下JMM内存模型吧

主要分为两个区域：线程私有区域和线程共享区域

线程私有区域：

* 程序计数器：程序计数器用来存放执行指令的行号指示器和偏移量等，线程执行或恢复都要依赖程序计数器
* 虚拟机栈：Java 中的虚拟机是描述 Java 方法执行的内存区域；其中的元素用于支持虚拟机进行方法调用 每个方法从开始调用到执行完成的过程就是栈帧出栈入栈的过程，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表，操作数，动态连接，方法返回值等信息。
* 本地方法栈：本地方法栈与虚拟机栈的作用差不多相同，区别是本地方法栈为虚拟机使用native方法服务

线程共享区域

* 堆：Head是OOM故障最主要的发源地，它存储着几乎所有的实例对象，也是垃圾回收的主要场所

* 元空间：用于存放已被类加载的信息，常量，静态变量，即时编译后的代码等信息。

##### **2**.**内存泄漏和内存溢出以及栈溢出**

内存溢出：(out of memory)是指程序载申请内存空间时，没有足够的内存空间供其使用

内存泄漏：(memory leak)是指程序在申请内存后，无法释放已申请的内存空间。一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，

大量的内存泄漏会导致内存溢出

栈溢出：函数调用栈帧太深了,注意代码中是否有了循环调用方法而无法退出的情况

##### 3.类加载	**一个将 class 字节码文件实例化成 Class 对象并进行相关初始化的过程。**

1. 加载阶段：就是在硬盘上寻找java文件对应的class文件，并将class文件中的二进制数据加载到内存中，将其放在运行期数据区的方法区中去，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构；
2. 连接阶段：这个阶段分为三个步骤，步骤一：验证，验证什么呢？当然是验证这个class文件里面的二进制数据是否符合java规范咯；步骤二：准备，为该类的静态变量分配内存空间，并将变量赋一个默认值，比如int的默认值为0；步骤三：解析，这个阶段就不好解释了，将符号引用转化为直接引用，涉及到指针，这里不做多的解释；
3. 初始化阶段：当我们主动调用该类的时候，将该类的变量赋于正确的值(这里不要和第二阶段的准备混淆了)，举个例子说明下两个区别，比如一个类里有private static int i = 5;  这个静态变量在"准备"阶段会被分配一个内存空间并且被赋予一个默认值0，当道到初始化阶段的时候会将这个变量赋予正确的值即5，了解了吧！

##### 4. 双亲委派机制

如果想加载一个类，要非常礼貌地向上逐级询问 ：“ 请问，这个类已经加载了吗？ 被询问的高层次类加载器会自问两个问题，第一，我是否已加载过此类？第二，如果没有，是否可以加载此类？只有当所有高层次类加载器在两个问题上的答案均为“否”时，才可以让当前类加载器加载这个未知类。

自定义加载器——》应用类加载器——》扩展类加载器——》启动类加载器

##### 5.类加载时机

* 创建对象时（new）或访问某类的静态资源时
* 反射
* 初始化某个类的子类，则其父类也会被初始化
* 启动类，就是使用Java.exe命令的

##### 6.GC    就是回收内存中已经无用的垃圾（对象）

###### 	6.1 判断对象是否为垃圾

* 引用计数法

  给每一个对象设置一个引用计数器，当有一个地方引用该对象时，引用计数器+1.引用失效时，引用计数器-1；当引用计数器为0时，就说明这个对象没有被引用，也就是垃圾对象，等待回收

  缺陷：循环引用

* 可达性算法

  以GC Roots为根节点，如果对象没有直接或间接和GC Roots引用关系，则可以被回收

  > Java中可以作为GC Roots对象的有以下几种：
  >
  > ​			1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
  >
  > ​			2. 方法区中类静态属性引用的对象
  >
  > ​			3. 方法区中常量引用的对象
  >
  > ​			4.本地方法栈中JNI(Native方法)引用的对象

  根据结果，可将对象分为

  * 强引用：无论内存是否足够，也不会回收
  * 软引用：当内存不够时，在系统将要发生内存溢出异常之前，回收掉
  * 弱引用：无论内存是否足够，都会回收
  * 虚引用：顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。**回收时收到一个系统通知**。

###### 6.2 垃圾回收算法

* 标记-清除算法	（老年代算法）

  该算法会从每个GC Roots出发，依次标记有引用关系的对象，没有标记的对象将被清除

  缺陷：1. 效率问题 	2.产生大量内存碎片

* 复制算法 		(新生代算法)

  把内存分为两个区，空闲区和对象区；垃圾回收时只需把存活的对象复制到另 一块未空闲空间上，将空闲空间标记为对象区，将对象区标记为空闲区，然后清除原空间中的原对象

  优点：会节省50%的内存空间

* 标记-整理算法		（老年代算法）

  首先会从 GC Roots 发标记存活的对象，然后将存活对象整理到内存空间的一端，形成连续的已使用空间 最后把已使用空间之外的部分全部清理掉 这样就不会产生空间碎片的问题。

* 分代收集算法

  java堆 = 新生代+老年代；

  ​	新生代=Eden+Survivor（S0+S1），默认分配比例为：8：1：1

  * 当Eden区满了的时候，就会触发一次Minior GC，来收集新生代的垃圾，存活下来的对象会被分配到其中一个Survivor区
  * 大对象会直接被分配到老年代
  * 当年龄到达15（经历15次minor GC）时，就会晋升到老年代
  * 当老年代满了，无法容纳更多对象，会触发一次Full GC；Full GC存储的是整个内存堆（包括年轻代和老年代）
  * 当S区内存不够时，就会向老年区借空间，如果老年区内存不够，老年区触发Major GC

##### 7. 垃圾收集器

###### 	CMS		老年代回收器

​	标记-清除算法

​	通过初始标记，并发标记，重新标记，并发清除四个步骤完成垃圾回收工作。1，3阶段会STW，2，4会并发操作。

> 缺陷：
>
> 1. CPU占用率问题
>
>    				2. 垃圾回收阶段产生的垃圾只能等下一次minor GC才能回收
>    				3. 内存碎片问题

###### 	G1		介于老年代与新生代之间

​	整体标记整理算法，局部复制算法

​		新生代区域：

* G1将Java堆空间分割成若干相同大小的区域，即region，包括Eden,Survivor,Old,Humongous四种类型。这样的划分意味着不需要一个连续的内存空间管理对象，而且使用的是复制算法，所以不会产生大量的空间碎片。G1还有一大优势是可预测停顿时间，能够尽可能在指定时间完成垃圾回收任务。

  老年代区域：

* 初始标记，并发标记，最终标记，筛选回收。1，3阶段会STW，2，4会并发操作。
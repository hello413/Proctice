# 简历信息



## 软件测试

#### 软件测试的流程

+ 需求分析、测试计划、测试开发、测试执行、测试评估

需求阶段：对需求分解、得出测试需求

计划阶段：根据需求编写测试计划/策略（测试点和测试方法）https://blog.csdn.net/zimingzim/article/details/89405997

设计阶段：了解设计有助于些用例，搭建测试用例框架，编写一部分用例

编码阶段：已经编码的部分专业的白盒测试可以执行单元测试，细化用例调整计划

测试阶段：根据用例和计划执行测试，记录缺陷，编写测试报告

运行维护：在项目试运行期间收集问题

#### 敏捷开发

+ 以人为核心、迭代、循序渐进的开发理念

工作方法有很多种，我了解到的是 Scrum

采用迭代开发的过程，将任务分解成多次连续的开发，逐步改进，增量交付

(按照新增功能来划分迭代)

制定产品需求列表：来自客户、市场(按优先级排序的明确可度量的需求列表)

计划会议：

各自的迭代：

迭代周期结束点：

评审、回顾：



![img](https://pic2.zhimg.com/80/v2-3fe4087afc61d3f671e84bf9b9c95f68_720w.jpg?source=1940ef5c)



#### W 模型和 V 模型

V  模型：把测试作为编码之后的一个阶段，清楚的表达了测试阶段和开发过程各阶段的对应关系，并没有在需求开发阶段就进入测试

**在单元测试和集成测试中我们就需要检测程序的执行是否满足软件设计的要求**

**系统测试对应于需求分析和系统分析，检测系统的功能，性能，质量上是否满足系统要求的指标**

**验收测试对应于用户需求阶段，确定软件的实现是否已经满足用户的需求**

​		![img](https://img-blog.csdn.net/20180909162435478?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTI3Nzg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



​			W 模型：增加了软件开发阶段中用应同步进行的验证和确认活动，能比较早的排查出问题

![image-20200920093014307](D:/typora/appdata/image-20200920093014307.png)

#### 缺陷的生命周期

无效的Bug：open—>closed   open—>rejected—>closed

+ 测试人员对每一个缺陷的修改必须重新取一个包含更改后的代码的新版本进行回归测试，确保相同的问题不出现，才能关闭缺陷
+ 对于拒绝修改和延迟修改的 Bug，需经过测试和开发用户代表的评审

![image-20200920111450575](D:/typora/appdata/image-20200920111450575.png)

#### 缺陷的描述

+ 发现问题的版本

开发人员需要知道出现问题的版本,才能够获取对应版本的代码来重视故障，并且版本的标识也有利于统计每个版本的质量

+ 出现问题的环境

环境氛围硬件环境和软件环境，如果是 web 项目还需要描述浏览器和客户机操作系统；如果事app项目要描述机型、分辨率、操作系统版本

+ 错误重现的最短步骤(描述问题重现的最短步骤)

+ 预期行为的描述

让开发知道怎么才是正确的，尤其是以客户的角度来描述程序的行为，如果是依据需求提出的故障，能写明需求的来源

+ 错误行为的描述

描述错误的现象。crush 等可以上传log，UI 问题有截图

+ 其他：故障分类，优先级，不要把多个 bug 放在一起



#### 用例设计

等价类：有大量数据输入的地方，划分有效、无效等价类，毕竟不能做到穷举

+ 有效等价类：测试功能是否正确实现
+ 无效等价类：测试程序是否有强大异常处理能力（健壮性）
+ eg：用户名有 6 -15 位字符串组成
  + 有效：6-15 位A-Z、a-z
  + 无效：数字，特殊字符
  + 上面的等价类还可以细化

边界值：有数据输入的地方，数据边界，往往和等价类一起使用，也有其他情况比如：

​		  性别：就不需要一起使用，有效就是男女，无效就是除了男女之外的字符

因果图：适用于输入条件存在约束关系、组合关系等

上面三者前两种着重于考虑输入条件，如果程序输入之间没什么联系采用等价类划分和边界值，有与、或、非等等这样的关联关系就要用因果图

![img](https://images0.cnblogs.com/blog2015/731029/201503/221128528121868.jpg)

错误推测：不单独使用，会和别的用例设计结合，重要的是思考和分析测试对象的各个方面，多参考以前发现的 Bug 相关数据，总结的经验，比如输入框，有的只是输入数字电话号，那程序员一般不会出错，但是有的有字符、数字等等的结合，这样的输入框出错的概率大。比如一个页面有很多个模块，查询商品信息和购买，那可能购买的出现问题可能性大



#### 什么是性能测试

针对性能指标，建立性能测试模型，制定性能测试方案，制定监控策略，在场景条件之下执行性能场景，分析判断性能瓶颈并调优，最终得出性能结果来评估系统的性能指标是否满足既定值 

+ 性能指标



+ 性能模型

  模型：是真实场景的抽象，比如

+ 性能方案

  其内容包含：测试环境、测试数据、测试模型、性能指标、压力策略、精准的准入准出和进度风险

+ 预定条件

  硬件环境、测试数据、测试执行策略、压力补偿

+ 性能场景



![img](https://uploadfiles.nowcoder.com/images/20200322/61899266_1584876060817_93D7E5F740AC3B5B91F8374F49CD10FA)



#### LoadRunner

后端性能测试工具首先通过虚拟用户脚本生成器生成基于协议的虚拟用户脚本，然后根据性能测试场景地设计要求，通过压力控制器控制协调各个压力产生器以并发地方式执行虚拟用户脚本，并在测试执行中通过系统监控器收集各种性能指标以及资源占用率，最后通过测试结果分析器展示测试结果数据。

+ 工具

Virtual User Generator：生成模拟用户的测试脚本 (录制客户端和服务器之间的通信协议，最终转化为代码化的虚拟用户脚本)

LodRunner Controller：负责控制 Load Generator 产生测试负载，以执行预先设定好的性能测试场景，收集各类监控数据

LoadRunner Analysis：分析插件，图形化的展示测试过程中收集的数据，还能对各个指标做关联分析，根本目的是分析出系统可能的瓶颈点以及潜在性能问题

+ 如何基于 LoadRunner 性能测试

  + 性能能需求收集和负载计划制定
  + 录制并增强虚拟用户脚本
  + 创建并定义性能测试场景
  + 执行性能测试场景
  + 分析测试报告

  其中获取性能测试需求和性能测试结果分析、问题定位是比较难的点，而类似于性能测试脚本开发、场景设计等偏向于机械性地重复工作

  ![image-20200921093448368](D:/typora/appdata/image-20200921093448368.png)



![img](https://img-blog.csdnimg.cn/20200810232826331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDg4OTM2,size_16,color_FFFFFF,t_70)



#### 自动化测试

指软件测试的自动化，在正常和异常情况下运行应用程序或系统，最后评估运行结果，将人为驱动的测试转化为机器执行的过程。可以在测试过程中任何一个阶段实时，前提功能相对稳定

**UI自动化**：用例维护量大；页面相关性强，必须后期介入；UI 测试适合与界面变动较小的项目

**接口自动化**：可在产品前期介入；用例维护量小、页面相关性小、适合接口变动小，界面频繁变

**优势**：降低回归测试的人力投入，特别是针对程序修改比较频繁时，自动化测试前期人力投入较多，但后期进入维护期后，可减少重复测试的时间。

**适用项目**：需求变动不频繁，项目周期足够长、自动化测试脚本可重复使用 (例如产品型项目，新版本是在旧版本基础上改进，功能变动不大，但项目的新老功能都必须重复的进行回归测试；机械频繁的测试，比如每次都输入大量数据)

**如何实施**：

1. 分析：把握测试系统逻辑，分析出系统的核心体系架构
2. 设计：设计测试用例，要足够明确和清晰，覆盖面广而精
3. 实现：实现脚本，有两个要求：一是断言、二是合理的运用参数化
4. 执行：执行脚本的异常需要仔细分析原因
5. 总结：测试结果的温习，和测试过程的总结
6. 维护：脚本维护
7. 分析：用例覆盖风险和脚本维护的成本

WebDriver：是API，用不止一种语言编写，具有控制浏览器的功能

selenium：web自动化测试工具，免费，小巧一个包

支持多平台：windows、linux、MAC 

支持多浏览器：ie、safari、opera、chrome

自动化测试框架一般可以分为两个层次：

上层是管理整个自动化测试的开发，执行以及维护，在比较庞大的项目中，
它体现重要的作用，它可以管理整个自动测试，包括自动化测试用例执行的次序、测试脚本的维护、以及集中管理测试用例、测试报告和测试任务等

下层主要是测试脚本的开发，充分的使用相关的测试工具，构建测试驱动，并完成
测试业务逻辑。

自动化测试的演变：测试工具----数据驱动----关键字驱动----测试框架----测试平台  

Selenium2将浏览器原生的API封装成WebDriver API，可以直接操作浏览器页面里的元素，甚至操作浏览器本身（截屏，窗口大小，启动，关闭，安装插件，配置证书之类的）,所以就像真正的用户在操作一样。  

+ 启动浏览器后，selenium-webdriver会将目标浏览器绑定到特定的端口，启动后的浏览器则作为webdriver的 远端服务器。  
+ 客户端(也就是测试脚本)，发送HTTP请求给sever端（通信协议：The WebDriver WireProtocol，在HTTP request的body中，会以WebDriver Wire协议规定的JSON格式的字符串来告诉Selenium我们希望浏览器接下来做什么事情）。 
+ Sever端需要依赖原生的浏览器组件，转化Web Service的命令为浏览器native的调用来完成操作  

selenium1: 使用的是 JS 注入技术和浏览器交互(Selenium启动一个Server，将操作 Web 元素的 API 调用转化为一段段 JS，在selenium 内核启动浏览器之后注入这段 JavaScript，速度不理想，稳定性依赖于 Selenium 内核对 API 翻译成 JS 的质量)

selenium2：整合了webdriver 和 selenium，利用浏览器原生的 API，封装成一套，可以直接操作浏览器页面的元素和浏览去本身，使用原声 API 效率高



定位元素：

driver.find_element_id("kw").send_keys("记得")

name

class name

link text

partial link text

tag name

xpath

css selector

 

## 编程基础

#### 什么是编程

计算机为解决某个问题而使用程序设计语言编写代码，最终得到结构的过程。为了使计算机理解人的意图，必须将解决思路、方法以计算机能够理解的形式告诉他，使得他能够根据人的指令一步步完成工作，这种人和计算机交流的过程就是”编程“

#### Java SE

##### Java 语言

+ Java 是一门面向对象编程语言，

#####  JVM、JRE、JDK

+ JVM：java语言编写的程序需要运行再虚拟机上，不同的平台有自己的虚拟机，所以 java 语言可以实现跨平台
+ JRE：包含 JVM 和 java 程序的核心类库，核心类库主要是 java，lang包：包含了程序运行的系统类，如：基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包，所以要运行一个开发好的 java 程序只要安装 jre 即可
+ JDK：包含 java 开发工具、JRE，其中开发工具：编译工具(javac.exe)，打包工具(jar.exe)

![image-20201001104200104](D:/typora/appdata/image-20201001104200104.png)

##### 基础语法

+ 数据类型：
  + 基本数据类型（八大）
    + 数值型：整数类型（byte、short、int、long）浮点类型（float、double）
    + 字符型（char）
    + 布尔型（boolean）
  + 引用数据类型
    + 类、接口、数组、String

![image-20201001104911784](D:/typora/appdata/image-20201001104911784.png)

+ switch 能否作用在 byte 上，是否能作用在 long 、String 上？

在 java5 之前，switch(expr)中，expr 只能是 byte、short、char、int。java5 expr 也可以是枚举类型；从 java7 开始，expr 可以是字符串，但是long类型是一直不可以的

+ 强制类型转换

short s1 = 1; s1 = s1 + 1;  由于 1 是 int，因此 s1+1 也是 int，需要强制类型准换才能赋值给 short

short s1 = 1; s1 += 1; 同上分析，但是由于 += 这个复合运算隐含了强制类型转换，所以是可以编译通过的。

当使用算术运算符(+, -, *, /, %)时，只要两个数中有一个是 double/float/long 类型，另一个数也会被转换成double/float/long类型，并且结果也是相应类型；除了这三个，其他的类型(byte, short, int, char)，两个数都会被强制转换为int类型，并且结果也会被转换为int类型。  

+ 编码

采用 Unicode 编码，为每个字符定制了一个唯一的数值，因此在任何语言、平台、程序都可以放心使用

+ 访问修饰符

![image-20201001112211135](D:/typora/appdata/image-20201001112211135.png)

##### 关键字

+ final、finally、finalize 的区别
  + final 可以修饰类、变量、方法，修饰类不能被继承，修饰方法不能被重写，修饰变量该变量是常量不能再被赋值
  + finally 用在 try-catch 代码块，处理异常将必须执行的代码放在 finally 中，表示无论代码是否异常都执行，一般存放一些关闭资源的代码
  + finalize 是属于 Object 类的方法，而 Object 类是所有类的父类，该方法一般有垃圾回收器调用，当我们调用 System.gc() 方法时，由垃圾回收器调用 finalize() 判断一个对象是否可回收
+ this 和 super
  + this 可以理解为对象的引用，常用：直接引用代表对象本身；形参与成员重名用来区分；引用本类的构造
  + super 最近父类对象的引用，常用：当前对象的父类引用；子类成员变量或方法有父类同名用 super 区分；引用父类构造
  + super在子类调用父类构造，this在本类调用本类其他构造，均需放在构造方法第一行，因此不能出现在一个构造中；从本质上讲 this 是一个指向本对象的引用，而super 是java 一个关键字
+ static 存在的意义
  + 创建独立于具体对象的域变量或方法，一般用在对象之间需要共享值，方便访问
  + 形成静态代码块优化性能，因为只会在类加载时按照在类中的顺序执行一次
  + static 修饰的变量在内存只有一个拷贝，JVM 只为静态变量分配一次内存，类加载过程完成静态变量的内存分配，而实例变量是没创建一个实例，都会为其分配一次，内存中实例变量可以存在很多拷贝互不影响，static 不能修饰局部变量
  + static 修饰方法归类所有，可以理解为共享方法，不用消耗资源反复创建对象，类加载时已经在内存中，直到程序结束才被释放，实例方法在方法结束就会被回收
  + static 修饰类，内部类由可用 static 修饰，只能访问外部类的 static 成员，不能直接访问外部类的实例方法和实例变量
  + static 修饰代码块是在类中独立于类成员的 static 语句块，可以有多个，JVM 在执行类加载时会按顺序执行这些静态代码块，静态代码块是加载时自动执行，静态方法调用才执行

+ break、continue、return 作用

break 跳出总循环，结束当前循环体，continue 跳出本次循环，return 程序返回结束，不再继续执行。

在 java 中想要跳出多重循环久在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带标号的 break 语句，即可跳出

![image-20201001151446667](D:/typora/appdata/image-20201001151446667.png)

##### 面向对象基本特性

封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，便于使用，提高复用性和安全性  

继承：使用已存在的类的定义作为基础建立新的类，新类的定义可以增加新的数据或功能，也可以用父类的功能，但不能选择性的继承父类，通过使用继承能够方便复用以前的代码

多态：程序中定义的引用变量所指向的类的实例对象和调用的方法在程序运行期才确定。

两种形式实现多态：继承(子类对父类方法的重写) 和 接口(实现接口并覆盖接口中同一方法)

+ 方法重载：编译时多态，也称前绑定，根据参数列表的不同来区分不同函数，通过编译之后会变成两个不同函数，在运行时谈不上多态
+ 方法重写：实现的是运行时多态，也称后绑定

Java 语言如何实现多态：动态绑定、方法重写、向上转型

多态中的成员访问特点：

+ 成员变量：编译运行看左边
+ 成员方法：编译看左边、运行看又不安
+ 静态方法：编译和运行看左边(静态和类相关，算不上重写，所以房屋内还是左边的)

多态的弊端：不能使用子类特有的成员属性和子类特性有的成员方法，不过可以通过向下转型来解决这个问题，到那时向下转型不够安全（比如强制转换的引用不是第一次多态时的哪个引用）

面向对象：面向对象的编程方式使得每一个类都只做一件事，面向过程会让一个类越来越全能，像一个管家一样，类比活字印刷，模型化可维护、可扩展、可服用、灵活性

面向过程：解决一个问题，把事情拆分成一个个函数，按一定顺序执行完方法，按步骤、流程化的

面向对象：把事物抽象成对象的概念，给对象赋一些属性和方法，让每个对象去执行自己的方法。按功能划分

**面向过程的解决方法：**

1、执行加洗衣粉方法；

2、执行加水方法；

3、执行洗衣服方法；

4、执行清洗方法；

5、 执行烘干方法；

**面向对象的解决方法：**

1、我先弄出两个对象：“洗衣机”对象和“人”对象

2、针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法”

3、针对对象“人”加入属性和方法：“加洗衣粉方法”、“加水方法”

4、然后执行

人.加洗衣粉

人.加水

洗衣机.洗衣服

洗衣机.清洗

洗衣机.烘干

##### 抽象类和接口

![image-20201001152827115](D:/typora/appdata/image-20201001152827115.png)

抽象类可以使用 final 吗？当然不可，因为抽象类就是要让其他类继承的，用 final 修饰就矛盾了

+ 抽象类的规则

  + 没有方法体，只声明不实现，实现由子类完成
  + 方法不能是 private
  + 可以包含其他非抽象方法

+ 接口

  + 只有抽象方法(public abstract)，字段只能是静态常量
  + 类通过继承接口的方式，来继承接口的抽象方法
  + 接口可以继承自另一个接口，达到复用

+ 比较

  + 都是整合子类通用特性的，接口相当于抽象方法的集合

  + 接口中的方法默认是 public static final；方法默认是 public abstract

    

##### equals() 和 ==

== 比较地址值，即两个对象是不是同一个，equals() 比较的是内容，具体：类没有重写 Object 中的 equals() 方法，那通过 Object 类中的这个方法，则默认比较的是地址值==；第二种是重写了 equals() 方法，比较对象内容，相同 true，不同 false

##### hashCode 和 equals

HashSet 如何查重？比较哈希码

hashCode 的作用是获取散列码，实际上返回一个 int 帧数，这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中任何类都包含这个函数

hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）  

##### 值传递和引用传递

值传递：传递的参数是按值的拷贝，传递后互不关联

引用传递：传递的参数是引用，也就是内存空间地址，传递前后执行的是同一个内存空间

其实他们的区别并不是传递的内容而是实参有没有被复制一份

##### JDK 中常用的包

![image-20201001155528383](D:/typora/appdata/image-20201001155528383.png)

##### 反射

是在运行状态中，对于任意一个类，都能够直到这个类的所有属性和方法，对于任意一个对象，都能够调用他任意一个方法和属性，这种动态获取信息以及动态调用对象的方法的功能叫反射

+ 优点：运行期类型的欧安段，动态加载类，提高代码灵活度
+ 缺点：性能瓶颈，相当于一系列解释操作，通知 JVM 要做的事，性能比直接的 Java 代码慢
+ 应用场景：JDBC 连接数据库使用 Class.forName() 通过反射加载数据库驱动

##### Object 类



##### String

字符型常量和字符串常量的区别？

+ 形式上：字符串常量是单引号引起的一个字符，字符串常量是双引号引起若干个字符
+ 含义上：字符常量相当于一个整型值(ASCII 值)，可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）
+ 占内存大小：字符常量只占一个字节，字符串常量占若干，至少一个字符结束标志

特性

+ 不变性：Sting 是只读字符串，对他进行任何操作，其实都是创建一个新对象，再把引用指向该对象，主要作用在于当一个对象需要被多个线程共享并频繁访问时，可以保证数据的一致性
+ 常量池优化，String 对象创建后，会再字符串常量池中缓存，如果下次创建内容一样的就会直接返回缓存的引用
+ final：使用final 来定义 String 类，表示 String 类不能被继承，提高了安全性

在使用 HashMap 时，用 String 做 key 的好处？

HashMao 内部实现时通过 key 的 hashcode 来确定 value 的存储位置，因为字符串时不可变的，所以创建字符串时，它的 hascode 被缓存下来，下次不用算，相比快

String、StringBuilder、StringBuffer 的区别？

+ 可变性：String 是 private final char value[] ，所以不可，StringBuilder 和 StringBuffer 都继承自 AbstractStringBuider 类，在 AbstractStringBuider 中也是使用 char[] value 保存
+ 线程安全：String 对象不可变，线程安全，StringBuffer 对方法加了同步锁，安全，StringBuilder 非线程安全
+ 性能：每次多 String 类型改变都会生成一个新的 String 对象，然后将引用指向新的对象。StringBuffer 每次都会对 StringBuffer 本身操作而不是生成新对象，相同情况下使用 StrignBuilder 仅能获得10%-15% 的性能提示，却线程不安全
+ 总结：如果要操作少量的数据用 = String  ；单线程操作字符串缓冲区 下操作大量数据 = StringBuilder  ；多线程操作字符串缓冲区 下操作大量数据 = StringBuffer  

包装类

![image-20201002093820438](D:/typora/appdata/image-20201002093820438.png)



![image-20201002093847661](D:/typora/appdata/image-20201002093847661.png)

![image-20201002093915966](D:/typora/appdata/image-20201002093915966.png)



#### Java 集合

Java 是面向对象的语言，避免不了处理对象，要操作对象需要存储，存储多个对象很容易想到容器，比如数组（虽然有对象数组，但是数组不可变）和 StringBuffer，所以 java 提供了集合。

数组和集合的区别：

+ 长度区别
  + 数组长度固定
  + 集合的长度可变（底层有扩容机制）
+ 元素的数据类型
  + 可存储基本和引用
  + 集合只能存储引用

Java 容器分为 Collection 和 Map 两大类

+ Collection 
  + 多个元素不能相同，按照某个规则排序
  + 针对不同功能有不同子接口 Set、List、Queue
    + List：一个有序（元素存入和取出的顺序一致）容器，元素可以重复，可以插入多个 null 元素，元素都有索引，List 可以通过下标访问，常用的实现类有，ArrayList、LinkedList、Vector
    + Set：一个无序（元素存入和取出顺序可能不一致）容器，不可以存储重复元素，只允许存入一个 null 元素，必须保证元素的唯一性，Set 不可以通过下标访问，常用实现类：HashSet、TreeSet、LinkedHashSet
+ Map 是一个键值对集合，存储键、值之间的映射。key 无序且唯一，value 不要求顺序，允许重复。Map 常用实现类有：HashMap、TreeMap、LinkedListMap、HashTable、ConcurrenthashMap

##### ArrayList 和 LinkedList

+ 线程安全：都是不同步，非线程安全的
+ 数据结构：ArrayList 使用数组实现，LinkedList 底层是双向链表
+ 插入和删除
  + ArrayList 基于数组，在插入和删除元素时，使用 add() 方法且默认尾插，时间复杂度为 O(1)，但在指定 i 位置插入时间复杂度是 O(n-i)
  + LinkedList 采用双向链表，插入和删除时间复杂度都不受元素位置影响，都是近似于O(1)
  + 对于大数量级的顺序插入选择 ArrayList，因为虽然ArrayList 需要扩容但是对比 LinkdeList 每次都需要创建新对象更快
+ 扩容机制
  + LinkedList 底层是双向链表，没有初始化大小和扩容机制
  + ArrayList 若不指定大小，初始为 10，在使用 add 方法会先调用 ensureCapacityInternal 方法，传入 size+1 检查是否需要扩容，newCapacity = 原数组的1.5倍；拷贝数组核心是 System.arraycopy() 方法
+ 内存占用：ArrayList 空间浪费体现在 List 结尾要预留一部分空间，而 LinkedList 体现在每一个元素额外要存放下一个的引用
+ 百万级以上的数据还是要用 ArrayList，因为 LinkedList 的时间主要消耗在遍历上，而 ArrayList 消耗在移动和复制上，遍历速度慢于复制速度。

##### ArrayList 和 Array

+ 区别
  + Array 可以容纳基本数据类型和对象，而 ArrayList 只能容纳对象
  + Array 是指定是指定大小的
+ 应用场景
  + 数组大小确定，主要操作时存储和遍历
  + 操作基本数据类型、多维数组

##### HashMap

+ 实现原理

  + jdk1.7 中：拉链法，数组和链表的结合
  + jdk1.8 中：数组+链表/红黑树，当链表元素个数超过 8 个（产生hash冲突的元素）且数组长度 >= 64 时会自动转换成红黑树，节点变为树节点，当长度下小于 6 时又会变为链表

+ 采用 put 方法添加一对键值对

  系统首先会计算 key 的 hash 值，然后根据 hash 值确认在 table 中存储的位置，如果该位置没有元素则直接插数组中；如果有判断是红黑树节点就插入树中，否则插入链表(1.8 是尾插，1.7是头插)

+  get() 方法

  通过 get(key) 中的 key 值找到 table 数组中索引处的 Entry，然后返回该 key 对应的 value；能够根据 key 快速取到 value，是因为 HashMap 存储中没有把 key 和 value 分开，而是当作一个整体 key-value 处理，这个整体就是 Entry 对象，在存储过程中，系统会根据 key 的 HashCode 来决定 Entry 在 table 中的存储位置，取的过程也同样根据 key 的 HashCode 取出相应的 Entry 对象；

  基于这个特点，HashMap 不能判断一个 key 是否包含在 map 中，因为 get 返回null 可能是因为map 中并不包含相应的 key，也可能是因为 key 对应的 value 值为 null

![image-20201003102712862](D:/typora/appdata/image-20201003102712862.png)

+ HashMap 允许键和值为 null，HashTable 和 ConcurrentHashMap 不允许
+ HashMap 不保证线程安全，HashTable 和 ConcurrentHashMap 是线程安全的
+ 效率
  + 因为 HashMap 不保证线程安全，效率最高适用于单线程
  + Hashtable 是使用 synchronize 修饰方法实现线程安全，效率低
  + ConcurrentHashMap 使用 CAS + synchronized 实现线程安全（put 方法存放元素时：通过 key 对象的 hashcode 计算出数组的索引，如果没有 Node，则使用 CAS 尝试插入元素，失败则无条件直到插入成功，如果存在 Node，则使用 synchronize 锁住该 Node 元素[链表/红黑树的头节点]，在执行插入操作，所以效率比 Hashtable 高）
+ 扩容机制
  + Hashtable 初始 11，扩容是 newsize = oldsize*2+1
  + HashMap 和 ConcurrentHashMap 初始 size 都是 16，扩容为 newsize = oldsize*2，size 一定是 2 的 n 次幂

#### 数据结构

+ 栈和队列

```
栈：实现了浏览器的前进和后退功能
栈：首先是先进后出特点，是一种 ”操作受限“ 的线性表，只允许在一端插入和删除，从功能上看确实可以用数组和链表代替，但是对于特定场景使用就很合适。

场景：当某个数据集合只涉及在一端插入合删除数据，并且满足先进后出特性就可以考虑这个数据结构

时空复杂度：不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。（这里谈论空间复杂度是指除了数据存储空间外，算法运行还需要额外的空间）。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)


CPU 资源有限，任务的处理速度合线程个数并不是正相关，过多线程反而因为 CPU 频繁切换性能下降。所以线程池的带线啊哦都是综合考虑要处理任务的特点合硬件环境事先设置

队列：就是排队买票先来先买，先进先出
基本操作：入队和出队，
也是一种操作受限的线性表数据结构，应用广泛，特别是一些具有特性的队列：循环、阻塞、并发等
非循环队列：队满 tail == n         队空 head == tail
循环队列：队满 (tail+1)%n = head  （tail 位置没有数据，浪费一个空间）
阻塞队列：在队列的基础上加了阻塞操作，就是队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列有数据才能返回；如果队列已满，插入数据操作就会被阻塞，直到队列中有空闲位置后再插入数据，再返回。

基于阻塞式队列实现的 ”生产者-消费者“模型，可以有效地协调生产和消费速度，当生产速度过快，消费者来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到消费者消费了数据，生产者会被唤醒继续生产。

而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。就是在多线程情况下，会有多个线程同时操作队列，会存在线程安全问题，如何实现一个线程安全的队列？

线程安全的队列我们称并发队列，最简单直接的方式是在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度比较低，同一时刻仅允许一个存或取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           // 栈的大小

  // 初始化数组，申请一个大小为 n 的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }

  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回 false，入栈失败。
    if (count == n) return false;
    // 将 item 放到下标为 count 的位置，并且 count 加一
    items[count] = item;
    ++count;
    return true;
  }

  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回 null
    if (count == 0) return null;
    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}


```



#### 数据库

（CURD、索引、事务管理和调优）



##### 索引

索引的出现就是为了提高数据查询的效率，好比书的目录一样

+ 常见模型
  + 哈希表以键-值存储的结构，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组这个位置，出现冲突时采用拉链法
    + 由于是hash产生并不是顺序的所以新增速度快只需要往后追加，但是由于无序做区间查询速度慢。适用于等值查询的场景
  + 有序数组
    + 在等值查询和范围查询场景中性能比较好，可以直接二分查找；如果仅看查询效率，有序数组就是最好的，但是需要更新就成本很高，所以只适于静态存储引擎
  + 搜索树
    + 查找的时间复杂度是 O(log(N))，为了维持平衡更新的时间复杂度也是 O(log(N))，虽然二叉树效率高，但实际用的多叉树，因为索引不止在内存中，还要写到磁盘上。
    + 对于 100 节点的平衡二叉树，树高 20.依次查询可能要访问 20 个数据块，对于机械硬盘，读取一个需要 10ms 左右，而 100 行的表，单独访问一个可能需要 20 个 10 ms，这比较慢。为了让一个查询少读磁盘，必须让查询少访问数据库，用 ”N“叉树，这 N 取决于数据块大小。以 InnoDB 的一个整数字段看，这个 N 差不多 1200，树高 4，可以存 1200 的 3 次方也就是 17亿，考虑到树根的数据块总是在内存中，一个 10 亿行的表上一个整数字段的索引，查找一个值最多需要访问 3 次磁盘，其实，树的第二层也很大概率在内存，访问的磁盘数就少了。

+ MySQL

  + MySQL中，索引是存储引擎层实现的，不同的存储引擎的索引工作方式不一样，即时多个存储引擎支持同一种类型的索引，其底层实现也可能不同。

  + InnoDB 表是根据主键顺序以索引的形式存放的，每一个索引在 InnoDB 中对应一个 B+ 树

  + 主键索引和普通索引的查询区别：

    ```
    如果语句是 select * from T where ID = 500,即主键查询，只需要搜索 ID 这棵 B+ 树；
    如果语句是 select * from T where k = 5，即普通索引，需要西先搜索 k 索引树，得到 ID 为500再到ID索引树搜索一次，这个过程称为回表，也就是非主键索引的查询需要多扫描一棵索引树，所以尽量使用主键查询。
    ```

    ```
    select * from T where k between 3 and 5 需要执行几次树的搜索操作，会扫描多少行
    
    在 k 索引树上找到 k = 3 的记录，取得 ID = 300
    再到 ID 索引树查到 ID=300对应的 R3
    在 k 索引树取下一个值 k=5，取得 ID=500
    再到 ID 索引树查到 ID=500对应的 R4
    在 k 索引树取下一个值k=6，不满足条件，循环结束
    
    以上，回到主键索引树搜索的过程称为：回表
    由于查询结果所需要的数据只在主键索引上不能不会表，有没有可能经过索引优化避免回表呢？
    
    若是 select ID from T where k between 3 and 5 则此时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果不需要回表。
    
    即在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。可以减少树的搜索次数，显著提升查询性能，所以是一个常用的性能优化手段。
    ```

    



+ 事务



+ 调优



#### OSI

应用层：所有应用程序的网络在次展开

表示出：数据心事，完成对传输数据的转化(数据的加密解密)

会话层：负责建立、维护、拆除会话（session缓存）

传输层：负责建立一个可靠的端到端的连接

网络层：负责路由寻址和广播

数据链路层：负责将上层数据封装成帧

物理层：只负责传输01二进制比特流

 

#### IP

+ 保留 IP 地址 (只用在局域网中)

  网络号：

  ​	10

  ​	127

  ​	172.16.0.0 — 172.31.255.255

#### 常用 DOS 命令

ipconfig/all : 查看电脑的物理地址信息

arp -a : 查看 ip 和物理地址的对应关系

ping 网络地址：当前和要访问的能否连通

cls ：清屏



#### SQL



limit 和 offset 用法：

mysql 里分页一般用 limit 实现，select * from test limit 3,当 limit 后面跟一个参数的时候，该参数表示要取得数据得数量，表述直接取前3条数据；当 limit 后面跟两个参数得时候，第一个数表示要跳过得数量后面一位表示要取得数量：

select * from test limit 1，3 		// 表示取 2，3，4 条记录

select * from test limit 3 offset 1	// 表示取 2，3，4 三条记录

// 在 mysql 5 后支持这种写法，当limit 和 offset组合使用时，limit 后面只能由一个参数，表示要取得数量，offset表示要跳过得数量



什么是 内连接、外连接(左、右、全)、交叉连接、笛卡儿积

内连接：只连接匹配的行

左外连接：包含左边表的全部记录，以及右边匹配的记录

select * from a left join b on a.字段 = b.字段

右外连接：包含右边表的全部记录，以及左边匹配的记录

select * from A right join B on A.字段 = B.字段

全外连接：包含左右两个表的全部记录，不论另外一边的表是否存在匹配的行



交叉连接：生成笛卡儿积，不用生成任何匹配或选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

例如：select type name from title cross join publishers order by type



groub by 表里面有重复记录的时候要依赖这个进行分组

对于 distinc 与 group by 的使用：

当系统的性能高并且数据量大的时候用 group by

当系统的性能不高时或者使用数据量少时两者皆可

但是尽量使用 group by



**多进程优点：**

每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；
通过增加CPU，就可以容易扩充性能；
可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系；
每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大

**多线程缺点：**

逻辑控制复杂，需要和主程序交互；
需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算
多进程调度开销比较大；

#### Java 虚拟机

##### 虚拟机的启动

Java 虚拟机的启动时通过引导类加载器（bootstrap class loader）创建一个初始类(initial class) 来完成的，这个类是由虚拟机的具体实现指定的

##### 虚拟机的执行

+ 一个运行中的 Java 虚拟机由有一个清晰的任务：执行 java 程序
+ 程序开始执行时才运行，程序结束时就停止
+  执行一个 Java 程序时，真正在执行的时一个叫做 Java 虚拟机的进程

##### 虚拟机的退出

+ 程序正常执行结束
+ 程序在执行中遇到了异常或错误而异常终止
+ 操作系统出现错误导致 Java 虚拟进程终止
+ 某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作
+ 除此之外，JNI(Java Native Interface) 规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况

##### 类加载的过程

![image-20201005160726257](D:/typora/appdata/image-20201005160726257.png)

##### 双亲委派

Java 虚拟机对 class 文件采用的是按需加载，需要该类才会将他的class 文件加载到内存生成 class 对象，而且加载某个类的 class 文件采用的是双亲委派，就是把请求由父类处理。

+ 工作原理

一个类加载器收到类加载请求不会自己加载，而是把请求委托给父类加载器执行；如果父类加载器还存在其他类加载器就进一步向上委托，请求最终到达启动类加载器；如果父类加载器可以完成就成功返回，若无法完成子类加载器才会尝试加载

+ 优势
  + 避免类的重复加载
  + 保护程序安全，防止核心 API 被随意篡改
    + 自定义 String 类，在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载中会先加载 jdk 自带的文件（rt.jar 包中的 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 String 类，这样就能保证核心代码安全，--沙箱安全机制

##### JVM 中的多线程

线程是一个程序里的运行单元，JVM中应用的是多线程，并且每个线程都与操作系统的本地线程直接映射，当一个 Java 线程准备好执行后，一个操作系统的本地线程也同时创建，Java 线程终止后，本地线程也回收。操作系统所负责所有线程的安排调度到任何一个可用的 CPU 上，一旦本地线程初始化成功，就会调用 Java 线程中的 run() 方法



##### 类的初始化及主动使用

+ 创建了的实例
+ 访问某个类或接口的静态遍历或对该静态变量赋值
+ 调用类的静态方法
+ 反射
+ 初始化一个类的子类
+ Java 虚拟机启动时标明为启动类的类

##### JVM 的内存模型



###### 运行时数据区

PC 寄存器 虚拟机栈 本地方法栈 堆

PC 寄存器

+ 使用 PC 寄存器存储字节码指令地址编号有什么用？为什么用

  因为 CPU 会不停的切换各个线程，再切换回来后得知道从哪开始执行，JVM 字节码解释器就需要通过改变 PC 寄存器的值来明确系一条应该执行什么样的字节码指令

+ PC 寄存器为什么会设定为线程私有

  因为 CPU 时间片轮转执行，一个内核面对多个线程特定时间内只会执行某一个线程的方法，CPU 会不停做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差？为了能准确记录各个线程正在执行的当前字节码指令地址，最好的办法就是为每一个线程都分配一个 PC 寄存器，各个线程之间独立计算就不会出现干扰情况

虚拟机栈

+ 由于跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计基于寄存器的。基于栈的优点是跨平台、指令集小、编译器容易实现，缺点是性能下降，实现同样的功能需要更多指令

+ 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应一次次方法调用；生命周期和线程一致；主管Java 程序的运行，保存方法的局部变量、部分结果、并参与方法的调用和返回

+ 优点：

  + 是一种快速而有效的分配存储方式，访问速度仅次于 PC 寄存器
  + JVM 对 Java 栈的操作只有两个：
    + 每个方法执行伴随入栈
    + 执行结束出栈
  + 不存在垃圾回收

+ 栈中可能出现的异常

  + Java 虚拟机规范允许Java 栈的大下是动态或固定的，如果采用固定的那每一个线程的Java栈容量可以在线程创建时独立选定，如果线程请求分配的栈容量超过规范允许的最大容量会抛出 StackOverflowError
  + 如果可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存或创建新线程没有足够内存抛出 OutOfMemoryError

+ 每个线程都有自己的栈，每个栈中的数据都是以栈帧存储的。JVM 对 Java 栈的操作只有两个，对战帧的压栈和出栈，一个线程在一个时间点只有当前正在执行的方法的栈帧是有效的，称为当前栈帧，与当前栈帧对应的方法是当前方法，定义这个方法的类就是当前类。执行引擎运行的所有字节码指令只针对当前栈帧进行操作。若调用了其他方法，对应发新的栈帧会被创建出来，放在栈顶，称为新的当前帧

+ 不会存在一个栈帧中引用另外一个线程的栈帧。如果当前方法调用了其他方法，方法返回之际当前栈帧会传回此方法的结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使前一个称为当前帧。Java 方法有两种返回函数的方式，一种 return，一种是异常抛出，无论哪种都会导致栈帧弹出。

+ 每个栈帧存储：局部变量表、操作数栈、动态链接、方法返回地址、一些附加信息

  + 局部变量表（Local Variables）

    + 定义为数组，存储方法参数和方法体内局部变量，包括：基本数据类型、对象引用、返回地址类型，在线程栈栈帧里，是线程私有不存在安全问题

    + 容量大小是编译器确定的。局部变量表中国变量只在当前方法调用中有效，方法执行虚拟机使用局部变量表完成参数值到参数变量列表的传递，当方法结束后随着方法栈帧的销毁它也销毁。方法嵌套调用次数由栈大小决定，越大次数越多，当参数和局部变量变多会使得局部变量表膨胀，栈帧就越大，满足方法调用传递的信息越大，进而调用占用空间变大次数会减小

    + 参数在局部变量表数组的 0 开始，长度-1结束，最基本的存储单元是 Slot(变量槽)，其中32位以内的类型只占用一个slot，包括returnAdress；64位类型占用两个 slot；byte、short、char、boolean转换为int；long、double占用两个。JVM为每个局部变量表中的每一个Slot都分配一个访问索引，通过这个索引访问表中指定的局部变量值。当一个方法被调用时，他的方法参数和内部局部变量会展昭顺序被复制到每一个Slot上。64位只用使用前一个索引即可，如果是构造方法或实例方法创建的当前栈帧，该对象引用的 this 就会存放在索引 0 的solt处；slot是可以重用的，如果一个局部变量过了其作用域，之后申明心的局部变量可能会复用过去的槽位达到节省资源。

      ![image-20201006105310717](D:/typora/appdata/image-20201006105310717.png)

    + 类变量在”准备阶段“系统初始化赋0值，在”初始化“阶段在代码中定义初始值；局部变量表没有系统初始化过程一旦当以必须手动初始化否则不能用

    + 在栈帧中与性能调优密切的就是局部变量表，方法执行虚拟机使用局部变量表完成方法传递，变量也是重要的垃圾回收根节点，只要被变量表中直接或间接引用的对象都不会被回收

  + 操作数栈（Operand Stack）（或表达式栈）

    + 用于保存计算过程的中间结果同时是计算过程中变量临时的存储空间。在方法执行中根据字节码指令往栈中写入数据或提取数据，比如一些字节码指令将值压入，其余取出，使用后把结果再压入，常见的：赋值、交换、求和操作。
    + 每个操作数栈都有 一个明确的栈深度用于存储数据，最大值编译器确定，32bit占一个栈单位深度，64bit占两个。由于是栈实现不是采用索引访问数据通过标准入栈、出栈完成数据访问。
    + 被调用方法的返回值会被压入当前栈帧的操作数栈并更新 PC 寄存器中下一条需要执行的字节码指令

  + 动态链接（Dynamic Linking）（指向运行时常量池的方法引用）

    + 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用就能支持当前方法的代码实现动态链接。在 Java 源文件被编译到字节码文件中，所有的变量和方法引用都作为符号引用保存在 class 文件的常量池里，动态链接的作用就是为了将这些符号引用转换位调用方法的直接引用（常量池的作用就是提供一些符号和常量便于指令的识别）

      ![image-20201007135848008](D:/typora/appdata/image-20201007135848008.png)

    + 在 JVM 中，将符号引（通常是设计字符串的——用文本形式来表示引用关系）用转换位调用方法的直接引用与方法的绑定机制有关

      + 静态链接：字节码文件被装载到JVM内部，被调用的目标方法在编译器可知且运行期不变，这种情况下将调用方法的符号引用转换位直接引用的过程称之为静态链接，实现早期绑定

      + 动态链接：如果被调用方法在编译期无法确定，即只能在程序运行期将调用方法的符号引用转换位直接引用（JVM（或其它运行时环境）所能直接使用的形式），由于这种引用转换过程具备动态性就叫动态链接，实现晚期绑定

        (如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法；静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法，其他方法称为虚方法)

      + 方法重写的本质：

        1> 找到操作数栈顶的第一个元素所执行的对象实际类型，记为 C

        2> 如果在类型 C 中找到与常量中的描述符合简单名称都相等的方法，进行访问权限验证，通过则返回这个方法的直接引用，查找过程结束：如果不通过则返回异常

        3> 否则按照继承关系从下往上依次对 C 的各个父类进行第2步的搜索和验证

        4> 若始终没有找到就抛出异常

      + 虚方法表：面向对象中会频繁用到动态分配，如果每次都要重新在类的方法元数据中搜索合适的目标会影响到执行效率，为了提高性能，JVM就在类的方法区建立于格虚方法表，使用索引代替查找，每个类中都有一个存放这个方法的实际入口，并且他会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把类达到放发表也初始化完毕

      

  + 方法返回地址（Return Address）（方法正常或异常退出的定义）

    + 存放调用该方法的 PC 寄存器的值，方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的下一条指令的地址，方法异常退出时，返回地址是要通过异常表来确定，栈帧中一般不保存这部分信息
    + 本质上，方法的退出是当前栈帧出栈的过程，此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值，让调用者方法继续执行下去（正常完成出口和异常出口区别在于异常退出的不会给他的上层调用产生任何返回值）

  + 一些附加信息：对程序调试提供支持的信息

本地方法栈

​	管理本地方法的调用，是线程私有的。当某个线程调用本地方法时，它就进入了全新并且不再受虚拟机限制的世界，和虚拟机有同样权限，本地方法可以通过本地方法接口访问虚拟机内部的运行时数据区，可直接使用本地处理器寄存器，直接从本地内存的堆中分配任意数量内存

堆

一个 JVM 实例只存在一个堆内存，java 堆区在 JVM启动时被创建，大小也就确定了，-Xms 和 -Xmx 两个参数配置，前面用于表示堆区起始内存，后者用于表示堆区最大内存；通常会将两个配置一样目的为了垃圾回收清理完堆区后不需要重新分割计算堆区大小，提高性能。垃圾回收的重点对象，

![image-20201007161856433](D:/typora/appdata/image-20201007161856433.png)

分配对象的过程：

 1> new 的对象先放到伊甸园区域

 2> 当伊甸园区空间满时程序再创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载心得对象放到伊甸园区

 3> 然后将伊甸园中的剩余对象移动到幸存者0区

 4> 如果再次触发垃圾回收，此时上次幸存下放在幸存者0区的，如果没有回收就会放到幸存者1区

 5> 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去1区

 6> 什么时候区养老区？可以设置次数，默认 15 次

 7> 当养老区内存不足时，再次触发 GC，Major GC，进行养老区的内存清理

 8> 若养老区执行了 Major GC 之后发现依然无法进行对象保存就会 OOM

垃圾回收频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集

![image-20201007222033807](D:/typora/appdata/image-20201007222033807.png)



##### 为什么把 Java 堆分代，不分代就不能正常工作吗？

+ 不同对象的生命周期不同，大部分都是临时对象
  + 新生代：有Eden、两块大小相同的Survivor，s2 常为空
  + 老年代：存放新生代多次 GC 还存活的对象
+ 不分代也可以，分代的唯一理由就是优化 GC 性能，



方法区

虚拟机规范中说: 尽管所有的方法区在逻辑上是属于堆的一部分但一些简单的实现可能不会去选择进行垃圾回收，对于 HotSpot JVM，方法区还有一个名字叫非堆，所以方法区可以看作是独立于 Java 堆的内存

+ 线程共享，JVM启动时被创建，实际物理内存和堆一样不连续，可选择固定也可扩展，他的大小决定了系统可以保存多少类

+ 1.7 之前永久代，1.8开始用元空间，两个本质上有些类似都是对方法区的实现，不过区别在于：元空间不在虚拟机设置的内存中而是使用本地内存

  ![image-20201007232336955](D:/typora/appdata/image-20201007232336955.png)

+ 存储什么

  ![image-20201007233407874](D:/typora/appdata/image-20201007233407874.png)

  方法区有运行时常量池，字节码文件内部包含了常量池。编译后一个有效的字节码文件包含了类的版本信息、字段、方法以及接口等描述信息，还有就是常量池表，包括各种字面量和对类型、域和方法的符号引用。字节码需要数据支持，这种数据很大以至于不能直接存到字节码，而存到常量池，这个字节码包含了指向常量池的引用，在动态链接的时候会用到运行时常量池

  ![image-20201007234013201](D:/typora/appdata/image-20201007234013201.png)

  ![image-20201007234047267](D:/typora/appdata/image-20201007234047267.png)

  常量池可以看作一个表，虚拟机指令根据这个表找到要执行的类名、方法名、参数类型字面量等。

  ![image-20201007234440977](D:/typora/appdata/image-20201007234440977.png)

  ![image-20201007234538023](D:/typora/appdata/image-20201007234538023.png)

  ![image-20201007234618614](D:/typora/appdata/image-20201007234618614.png)

  ![image-20201007234633990](D:/typora/appdata/image-20201007234633990.png)

  ![image-20201007234647858](D:/typora/appdata/image-20201007234647858.png)

  方法区的垃圾回收：常量池中废弃的常量和不在使用的类型

  ![image-20201007234940582](D:/typora/appdata/image-20201007234940582.png)

  + 类信息

    ![image-20201007233043442](D:/typora/appdata/image-20201007233043442.png)

  + 域信息

    ![image-20201007233110968](D:/typora/appdata/image-20201007233110968.png)

  + 方法信息

    ![image-20201007233137031](D:/typora/appdata/image-20201007233137031.png)

  + 类变量

  + 全局常量：static final

  

###### 本地方法接口

一个 Native Method 就是一个 Java 调用非 Java 代码的接口，因为本地方法常用 C/C++ 实现，本地接口的作用是融合不同编程语言为 Java 所用，初衷是融合 C/C++程序，

#### GC

##### 简述一下 Java 的内存回收机制

在 Java 中，程序员不用显示的去释放一个对象的内存，由虚拟机自动执行的，在 JVM启动后由一个垃圾回收线程，他是低优先级的，会在虚拟机空闲或当前堆内存不足时出发，扫描没有任何引用的对象并回收

##### 垃圾回收原理？如何主动通知？什么时候触发？

对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址大小及使用了。

回收时机：

+ 显示手动调用 System.gc()，调用这个方法建议 JVM 进行 FGC，并非一定有效，但是一般都会触发 FGC
+ 由 JVM 垃圾回收机制决定：
  + 年轻代(Minor GC)触发：Eden满会触发，而Survivor满不会引发GC，由于java对象大多有朝生夕灭的特性，所以Minor GC比较频繁，回收速度比较块，而Minor GC 会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行
  + 老年代(Major GC)：出现了Major GC可能伴随至少一次的Minor GC，就是一般会先尝试触发 Minor GC 再去触发这个
  + 其他回收机制
    + java.lang.Object 有一个 finalize() 方法，当 JVM 确定不再有指向该对象的引用时，垃圾收集器会调用，允许子类重写用于对象被回收时进行资源释放，比如关闭文件、套接字和数据库连接。

##### 如何判断一个对象可以回收？垃圾回收策略、算法

+ 垃圾标记阶段，对象存活判断

  + 引用计数法：（Java没有选择，因为处理不了循环引用）
    + 在对象中添加一个引用计数器，每当有一个地方调用它时，计数器加 1 ，当引用失效时，计数器减1，当计数器为 0 时，这个对象就不会被使用可以回收
    + 实现比较简单，垃圾易于辨识，判定效率高
    + 单独的字段存储计数器增加了空间开销，每次赋值需要更新计数器增加时间开销，并且无法处理相互引用这种情况
  + 可达性分析算法（Java 或 C#）
    + 通过一系列的 GC Roots(根集合) 对象作为起点，从这些节点开始往下搜索，搜索走过的路径称为 GC Roots 引用链，当一个对象到 GC Roots 没有任何引用链连接时，这个对象不可用，只有能被根对象集合直接或间接链接的对象才是存活对象

+ 垃圾清除阶段，标记-清除算法、复制、压缩

  + 标记清除两项工作：标记，从根节点开始遍历标记所有被引用的对象，一般时对象的Header中记录可达；清除，对堆内存从头到尾线性遍历某个Header没有标记就清除
    + 效率不算高，GC时还要停止应用程序，清理出来的空闲空间不连续易产生碎片需要维护空闲列表
    + 这里的清除不是置空，而是把需要清除的对象地址保存在空闲列表，下次有新对象需要加载时，判断垃圾位置够不，够就放
  + 复制算法：将可用的内存划分为两部分，每次只用掉其中一部分，当这一部分内存快用完的时候，就将存活着的对象复制到另一块没有使用的内存上，然后把已经用掉的那一部分内存全部清理
    + 没有标记和清除过程实现简单运行高效，复制过去后空间连续没有碎片
    + 缺点是需要两倍的内存空间，适合垃圾多存活少的场景，一般在新生代的
  + 标记-压缩：效果等同于标记-清除后再进行碎片整理。标记的存活对象会被整理按照内存地址依次排列，未被标记的会被清理，这样当给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可
    + 消除了标记清除算法内存分散的特点，需要给新对象分配内存只需要持有一个内存的起始地址即可，消除了复制算法内存减半的高额代价
    + 效率要低于复制算法，移动对象时，如果对象被其他对象引用还要调整，移动过程需要暂停用户应用程序

  ![image-20201008112036226](D:/typora/appdata/image-20201008112036226.png)

前面算法没有一种可以完全替代其他的，分代收集算法应运而生，不同的对象生命周期不一样，不同的对象可以用不同的回收方式，可以按照新生代、老年代不同特点使用不同算法。

##### 分代收集算法

基于分代，GC使用的回收算法结合年轻代和老年代的特点

+ 年轻代：区域相对老年代小，对象生命周期短，存活率低，回收频繁，可以采用复制算法，速度是最快的，复制算法的效率只和当前存活对象大小有关，因此很合适年轻代的回收，而复制算法内存利用率不高的问题可以通过Survivor设计缓解

+ 老年代：区域大，对象生命周期长，存活率高，回收不及年轻代频繁，可以采用标记-清除或标记-清除与标记-压缩混合

  ![image-20201008112855598](D:/typora/appdata/image-20201008112855598.png)

  ​	![image-20201008112928730](D:/typora/appdata/image-20201008112928730.png)





##### Java 中的引用类型

+ 强引用：Object bj = new Object(); 只要强引用在，垃圾收集器永不会回收被引用的对象
+ 软引用：描述一些还有用但是并不很需要的，对于软引用关联的对象在系统要发生 OOM 之前会回收
+ 弱引用：非必须对象，只能生存到下一次 GC 之前，在下一次 GC  时，无论内存是都足够都会回收
+ 虚引用：幽灵引用，不会对对象的生存空间造成影响，也无法通过一个虚引用来获取一个对象实例，目的就是能在这个对象被 GC 时收到一个系统通知

##### 需要垃圾回收的内存

1> 元空间/方法区

+ jdk1.7 的方法区在 GC 中一般称为永久代
+ jdk1.8 的元空间存在于本地内存中，GC 就是对元空间垃圾回收
+ 方法区或元空间的垃圾回收主要是：废弃常量和无用类，回收性价比比较低

2> 堆

垃圾收集器主要管理的场所，也称为 GC 堆，由于分代收集还能细分

1. 新生代 (Young Generation)：新生代可分为 Eden区和Survivor
   + 新生代的垃圾回收称为：Minor GC 或者 Young GC
   + Minor GC 非常频繁且回收动作比较快
2. 老年代(Old Generation)：
   + 老年代回收：Major GC
   + 出现了 Major GC，一般都会伴随至少一次的 Minor GC
   + Major GC 一般比 Minor GC 慢十倍以上

##### 内存溢出和内存泄漏

内存溢出：没有空闲内存，并且垃圾收集器也无法提供更多。

+ 没有空闲说明Java虚拟机堆内存不够
  + 堆内存设置不够
  + 代码中创建了大量大对象且上时间不能被收集

内存泄漏：对象不会被用到，但是GC又不能回收

+ 单例模式
  + 单例的生命周期和应用程序一样长，所以对于单例程序如果持有对外部对象的引用，这个外部对象是不能回收的，会导致内存泄漏
  + 一些提供 close 的资源未关闭导致
    + 数据库连接(dataSource.getConnection())
    + 网络连接(socket) 和 io 连接必须手动 close

##### 垃圾回收器

+ 按线程数

  + 串行垃圾回收器
  + 并行垃圾回收器

+ 按工作模式

  + 并发垃圾回收器：与应用程序线程交替工作，尽可能减少应用程序的停顿时间
  + 独占垃圾回收器：停止应用程序中的所有用户线程，知道垃圾回收过程结束

+ 按碎片处理方式

  + 压缩式垃圾回收器：回收后对存活对象进行压缩整理，消除回收后的碎片
  + 非压缩式垃圾回收器：不进行

+ 按工作的内存空间分

  + 年轻代垃圾回收器
  + 老年代垃圾回收器

+ 经典的垃圾收集器

  + 串行：Serial、Serial Old

  + 并行：ParNew、Parallel Scavenge、Parallel Old

  + 并发：CMS、G1

    ![image-20201008144958691](D:/typora/appdata/image-20201008144958691.png)



#### 面试题

调优

+ 栈帧的局部变量表

栈溢出的情况？

+ 通过-Xss 设置栈的大小：OOM
+ 调整栈大小，就能保证不出现栈益处吗？不能

方法中定义的局部变量是否线程安全，具体问题具体分析

垃圾回收是否会设计到虚拟机栈？不会

解决 OOM 发方法？

通过内存映像分析工具对dump出来的堆转储快照分析，确认内存中的对象是否有必要，充分了解到底时内存泄漏还是内存溢出

![image-20201007232841966](D:/typora/appdata/image-20201007232841966.png)



#### Java 多线程

##### 进程间通信方式

+ 管道：速度慢, 容量有限, 只有父子之间的进程能通信;  
+ FIFO: 一种命名管道, 任何进程之间都能通信, 但是速度慢;  
+ 消息队列: 容量受到系统限制, 并且第一次读的时候,要考虑上次没有读完的数据;  
+ 信号量: 不能传递复杂消息, 只能用来同步;  
+ 共享内存: 速度快,但要保持同步  
+ 套接字: 可用于不同机器之间的额通信  

##### CPU 调度算法

+ 先来先服务（FCFS）

+ 短作业优先（SJF）
+ 时间片轮转调度
+ 优先级调度

##### 一个进程最多能有多少线程

默认一个线程的栈要预留 1 M 的内存空间，而一个进程中可用的额内存空间只有 2 G，所以理论上一个进程最多可用开 2048 个线程，但是内存不能完全来做线程的栈，所以实际应该比这个小

##### 为什么要引入多线程

+ 可以使多个线程处理任务提升效率
+ 如果阻塞点过多，一个线程处理不过来；例如 TCP 服务器再等待建立连接时候会阻塞，而这个流程不能因为这个而卡死在这，所以引入另外的线程去处理另外的任务。引入多线程要注意线程对共享数据修改的部分，必须考虑是否线程安全

##### 并发编程三要素，在 Java 中如何保证多线程安全

+ 原子性：一个或多个操作要么全部执行成功、要么全部执行失败

+ 可见性：一个线程对共享变量的修改，另一个线程能够立刻看到

  + 为了提高效率，JVM通常会将数据在工作内存中执行，这样就造成了共享变量在多线程之间不能被及时看到改变，造成可见性问题

  + 例如共享变量 sum++ 或者 sum--操作

    1> 读：线程读取主内存中 sum 的值，拷贝到工作内存

    2> 改：线程在工作内存中修改 sum 的值

    3> 写：线程把 sum 修改后的值写回主内存

    ![image-20201008155510689](D:/typora/appdata/image-20201008155510689.png)

+ 有序性：程序执行的顺序按照代码的先后顺序执行，处理器可能会对指令进行重排序，例如 new() 对象的操作可以分解为三条指令，下面2 和 3 就可能重排序：

  1> 分配对象内存空间（堆）

  2> 对象的初始化

  3> 对象赋值给变量（变量引用）

解决多线程安全的办法

1> synchronized、Lock可以解决原子性问题

2> volatile、Lock 解决可见性和有序性

##### 代码为什么会重排序

程序执行，为了提供性能。处理器和编译器常常堆执行重排序，但不能随便进行，需要满足下面条件：

1. 单线程环境下不能改变程序运行的结果
2. 存在数据依赖关系的不允许重排序

重排序不会影响单线程环境的执行结果，但会破坏多线程的执行语意



##### 并行、并发、串行

+ 并行：同一个时间点，多个处理器同时处理任务
+ 并发：多个任务在同一个CPU上，系统按时间片轮转调度使得这些任务交替轮流执行，从宏观上看这些任务好像是同时执行的
+ 串行：多个任务按顺序一个个执行

##### 进程和线程

+ 概念
  + 进程：一个在内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如 Windows 系统中，一个运行着的 .exe 就是一个进程
  + 线程：进程中的一个执行单元(控制单元)，负责当前进程中程序的执行，一个进程至少又一个线程，一个进程可以又多个线程，线程之间可以共享数据
+ 区别
  + 根本区别：进程是操作系统资源分配的最小单位，而线程是处理任务调度和执行的最小单位
  + 资源开销：每个进程都有单独的代码和数据空间，进程之间的切换会有较大的开销，同一类线程共享代码和数据空间，每个线程又自己独立的运行栈和程序计数器，线程之间的切换开销比较小
  + 包含关系：如果进程又多个线程，则执行过程不是一条线的，而是多条线程功跳完成的，线程是进程一部分，也被乘坐轻量级进程
  + 内存分配：同一个进程中的所有线程共享本进程的地址空间和资源，而进程之间的地址空间和资源都是相互独立的
  + 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，而一个线程崩溃其他线程也会受影响，整个进程都会崩溃，所以多进程要比多线程更健壮
  + 执行过程：每个独立的进程都有程序运行的入口，顺序执行序列和程序出口，但是线程不能独立执行，必须依存于进程

##### 什么是上下文切换？

当前任务执行完 CPU 时间片后切换到另一个任务之前会先保存自己的状态，以便下次时间片轮转再次回到这个任务时可以加载任务的状态，任务从保存到再加载的过程就是一次上下文切换。Linux 相比其他操作需要有很多优点，其中有一项就是：上下文切换和模式切换的时间消耗非常小

##### 守护线程和用户线程

+ 用户线程：运行在前台，执行具体的任务，如程序的主程序等都是用户线程
+ 守护线程：运行在后台，为其他前台线程服务，一旦所有的用户线程都结束运行 ，守护线程也会结束工作

最鲜明的区别是：用户线程结束，JVM 退出，不管这个时候还有没有守护线程运行，守护线程不会影响 JVM 退出

注意：

+ 在守护线程中产生的新线程也是守护线程
+ 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑
+ 守护线程不能依靠finally() 语句块中的内容来确保关闭或释放资源，因为一旦用户线程结束，守护线程会随着 JVM 一起结束工作，所有守护线程中的 finally() 语句块可能无法执行

##### 创建线程的四种方式

+ 继承 Thread 类
+ 实现 Runnable 接口
+ 实现 Callable 接口
+ 使用 Executors 工具类创建线程池

1. 继承自 Thread 类

   1. 定义一个 Thread 类的子类，重写 run() 方法，将相关操作实现，run() 方法就是线程要执行的业务逻辑方法

   2. 创建自定义的线程子类对象

   3. 调用子类实例的 start() 方法来启动项线程

      ```
      public class MyThread extends Thread {
      	
      	public void run(){
      		System.out.println(Thread.currentThread().getName()+"run()方法正在执行");
      	}
      }
      
      public class ThreadTest {
      	public static void main(String[] args) {
      		MyThread mt = new MyThread();
      		mt.start();
      		System.out.println(Thread.currentThread.getName()+"main()方法执行结束");
      	}
      }
      ```

2. 实现 Runnable接口

   1. 定义一个接口实现 Runnable 接口，并重写 run() 方法

   2. 创建 MyRunnable 的实例mr，以mr的对象作为target创建Thread对象，该Thread对象才是最终线程对象

   3. 调用线程对象的 start() 方法

      ```
      public class MyRunnable implements Runnable {
      	@Override
      	public void run() {
      		System.out.println(Thread.currentThread().getName() +
      	" run()方法执行mr中...");
      	}
      } 
      public class RunnableTest {
      	public static void main(String[] args) {
      		MyRunnable mr = new MyRunnable();
      		Thread thread = new Thread(mr);
      		thread.start();
      		System.out.println(Thread.currentThread().getName() +
      		" main()方法执行完成");
      	}
      } /
      /运行结果
      //main main()方法执行完成
      //Thread-0 run()方法执行中...
      ```

3. 实现 Callable 接口

   1. 创建实现Callable接口的类MyCallable；  
   2. 以MyCallable类的实例为参数创建FutureTask对象；  
   3. 将FutureTask对象作为参数创建Thread对象；  
   4. 调用线程对象的 start() 方法；  

   ```
   
   ```

4. 使用 Executors 工具类创建线程池

   Executors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExectorsSrrvice 接口，主要有：

##### 线程的 run() 和 start() 有什么区别？

+ start()方法用于启动线程，run() 方法用于执行线程运行时的代码，run() 方法可以重复调用，但是 start() 方法只能调用一次
+ star() 方法用于启动线程，真正实现了多线程的运行。调用 start() 方法时无需等
  待 run() 方法方法体代码执行完毕，可以直接继续执行其他代码；此时线程是就
  绪态，并没有开始运行，然后通过Thread类调用方法 run() 来完成其运行状
  态，run() 方法运行结束，此线程就终止了  
+ run() 方法是在本线程里的，只是线程的一个函数。如果直接调用 run() 方法，
  就相当于调用了一个普通的函数；直接调用 run() 方法时，必须等待 run() 方法
  执行结束才能执行下面的代码，所以执行路径还是一条，没有多线程的特征。
  所以在线程启动时，要调用 start() 方法而不是 run()方法。  

##### 为什么调用 start() 方法时会执行 run() 方法，不直接调用 run() 方法？

+ 多线程工作：new一个Thread类，线程就会进入新建状态；调用start() 方法，会启
  动一个线程并使线程进入就绪状态；当分配到时间片后就可以开始运行了。start()会执行线程的准备工作，然后自动调用run() 方法执行其里面的内容。
+ 如果直接调用run() 方法，会把run() 方法当成是一个main线程下的普通方法去执
  行，并不会在某个线程中执行它，不属于多线程的工作。  

##### 线程的生命收起和五种基本状态



1> 新建 new：创建一个线程对象

2> 可运行、就绪 runnable：线程对象创建完成之后，当调用线程对象的 start() 方法，该线程就处于可运行态，等待被系统调度选中，获取 CPU 使用权

3> 运行 running：可运行态的线程获取到 CPU 时间片，执行程序代码，且就绪态是进入到运行态的唯一入口

4> 阻塞 blok：处于运行态的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时就进入到阻塞态，直到其进入到就绪态，才有机会再次被 CPU 调入运行态。

阻塞态分为三种：

+ 等待阻塞：运行态的线程执行 wait() 方法，JVM 会把该线程放到等待队列，使本线程进入道等待阻塞状态
+ 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其他线程占用)，JVM 会把该线程放入到锁池(lock pool)中，线程会进入同步阻塞状态
+ 其他阻塞：通过调用线程的 sleep() 或 join() 或发出了 IO 请求时，线程会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 IO 处理完毕时，线程重新进入就绪态

5> 死亡：线程 run()、main() 方法执行结束，或因为异常退出了 run() 方法，该线程结束他的生命周期

##### Java 中用到的线程调度算法是

有两种调度模式：分是调度和抢占式调度：

+ 分时调度是指让所有的线程轮流获得 CPU 的使用权，并且瓶颈分配每个线程占用的 CPU 时间片
+ Java虚拟机采用的是抢占式调度模型，是优先让可运行池中优先级高的线程占用 CPU，如果可运行池中线程的优先级都相同，那么就随机选择一个线程，使其占用 CPU，处于运行态的 CPU 就会一直运行，直到不得不放弃 CPU

##### sleep() 和 wait() 有什么区别

两者都可以暂停线程的执行

+ 所在类不同：sleep是Thread类的静态方法wait是 Object 类的方法
+ 是否释放锁：sleep 不释放锁，wait 释放锁
+ 用途不同：wait 通常用于线程之间的通信，sleep 通常用于暂停线程的执行
+ 用法不同：sleep 方法执行完成后，线程会自动苏醒；wait 方法被调用后线程不会自动苏醒，需要依靠别的线程调用同一个对象上的 notify 或者 notifyAll 方法。wait 超时后线程会自动苏醒

### 

##### 为什么 wait、notify、notifyAll 方法必须在同步方法或同步代码块中调用

当一个线程需要调用 wait 方法时，这个线程必须拥有该对象的对象锁，才可以调用 wait 方法，释放该对象锁并进入等待队列，直到其他线程调用这个对象上的 notify方法，同样的，一个线程要调用对象的 notify() 方法时，他会释放这个对象的锁，以便其他在等待的线程可以获取到这个对象锁，这几个方法都是针对线程持有的对象锁进行操作的，所以只能在同步代码块中被调用

##### 如何停止一个正在运行的线程

1> run() 方法完成后线程终止

2> 使用 stop() 方法强行终止

3> 使用 interrup() 方法中断线程(是使用中断标志来实现，只是通知，并不是真的中孤单，而是由程序自行决定是否中断)

##### 同步方法和同步代码块，那个是更好选择？

同步块，因为一般不会锁住整个对象，而同步方法会锁住整个对象，哪怕这个类中有很多个不关联的同步代码块，这通常会导致他们停止执行取等待获得这个对象上的锁。同步块更符合开放调用的原则，只锁住需要锁住的代码块上的对象，可以避免死锁发送。

##### Synchronized 关键字

在多线程环境下用来控制线程同步的，synchronized 加到静态方法和代码块上都是给类加锁，加到实例方法上是给对象实例加锁。

项目中用到 synchronized 是是实现双重校验锁下的单例模式

##### 乐观锁和悲观锁的理解及如何实现

+ 悲观锁：总是很悲观的假设最坏的情况，每次拿数据的时候都认为别人会修改，所以在每次拿到的时候都会上锁，这样别人想拿这个数据就会阻塞，直到拿到锁（共享资源每次只给一个线程使用，其他线程阻塞等待，用完之后再把资源转让给其他资源）
  + 传统的关系型数据库里很多都用到了这种锁机制，比如行级锁，表级锁，读锁，写锁都是在做操作之前先加锁，Java中的synchronized 关键字的实现也是悲观锁
+ 乐观锁：总是很乐观的觉得：每次去拿数据的时候别人不会修改，所以不会上锁，在提交数据的时候才会正式对数据是否被修改，如果被修改就返回错误信息，乐观锁一般用于多读场景

##### 什么是线程死锁？

资源争夺上，两个或者两个以上的线程在执行过程中，互相持有对象的资源并且不主动释放造成的恶性循环，这些永远在相互等待的线程称为死锁

##### 造成死锁的四个必要条件

1> 互斥条件：线程对于所分配到资源具有排他性，即一个资源只能被一个线程占用，直到被该线程释放

2> 请求与保持条件：一个线程因为请求被占用的资源而发生阻塞时候，对已获得的资源保持不放

3> 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才会释放线程

4> 循环等待条件：当发生死锁，所等待的线程必定会形成一个死循环，造成永久阻塞

##### 如何避免死锁

需要破坏死锁的四个条件中的一个：

+ 破坏互斥条件：互斥条件没法破坏，因为使用锁本来就是想要他们互斥的
+ 破坏请求与保持条件：一次性申请所有的资源
+ 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，就主动释放它占用的资源
+ 破坏循环等待条件：按照某一个顺序来申请资源，释放资源按照反序释放

可以使用以下方法：

+ 尽量使用tryLock(long timeout,TimeUnit unit)的方法设置超时时间，超时就退出防死锁
+ 尽量使用 java.util.concurrent 并发类代替自己手写锁
+ 尽量降低锁的使用粒度，不要几个功能使用一把锁
+ 减少同步的代码块



##### 内存泄漏与内存溢出

泄漏：有些内存空间使用完毕后没有释放，导致一直占据着，直到程序结束

+ 使用单例造成的：因为单例的静态特性导致他的生命周期和应用的生命周期一样长，如果一个对象已经不需要再使用，而单例对象还持有这个对象的引用就会导致对象不能正常回收从而内存泄漏
+ 创建非晶态内部类或匿名内部类的对象可能造成，当外部剋结束，内部类还持有外部类的引用
+ 使用集合容器，完毕后没有把引用从集合中情空
+ 资源未关闭

溢出：

![image-20201008234550579](D:/typora/appdata/image-20201008234550579.png)

![image-20201008234612102](D:/typora/appdata/image-20201008234612102.png)

#### Linux

##### 涉及网络相关命令

```
ifconfig：查看与配置网络状态命令（看不到网关）
ifdown 网卡设备：禁用该网卡设备
ifup 网卡设备名：启动该网卡设备
netstat 参数：查询网络状态
		-t：列出 TCP 协议端口
		-u：列出 UDP 协议端口
		-n：不使用域名与服务器名，而使用 IP 地址和端口号
		-l：仅列出在监听网络状态服务（只有 TCP 有监听状态）
		-a：列出所有网络连接
		-r：列出路由列表，功能和 route 命令一致
		-rn：查看网关
route -n：查看网关
nslookup：用来翻译域名对应哪个 IP
ping ip或域名：探测指定 IP 或 域名的网络连通性（ping 时，客户机会向目标计算机发送一个 ICMP 数据包，然后对方会回应没时间越短表明网络速度越快，连接越顺畅）
telnet 域名或IP 端口：远程管理与端口探测命令，用来探测端口是否开启
troeroute 参数 IP或域名：路由跟踪命令
		  -n：使用 IP，不使用域名，速度更快
wget：下载命令
topdump 参数
		-i：指定网卡接口
		-nn：将数据包中的域名与服务转为 IP 和端口
		-X：以十六进制和 ASCII 码显示数据包内容
		port：指定监听的端口		
```

##### 目录文件相关

```
绝对路径：etc/test
主目录和当前目录和上层目录：~/ 和 ./ 和 ../
切换目录：cd (cd. 切换到上级目录；cd~ 切换到用户主目录；cd- 切换到最近访问目录)
清屏：clear
退出当前命令：Ctrl + c
执行睡眠：Ctrl + z 挂起当前进程，fg 恢复后台
查看指定帮助：man指令，可以查看某个指令含义及参数
eg：man ls：ls 命令功能，可以带哪些参数，有什么区别
ls 参数：用来查看指定目录下
   -a：列出目录下所有文件，包含隐藏文件
   -l：列出文件及其详细信息
   -r：列出所有子目录下的文件
创建目录：mkdir
创建文件：touch
复制文件：cp
删除文件：rm (-f:直接删除；-i：删除前逐一询问确认；-r：删除目录及下所有文件)
移动文件：mv
查看文件内容有什么命令：
	vi 文件名：用编辑方式查看，可以修改
	cat 文件名：显示是全部文件内容
	more 文件名：分页显示文件内容
	less 文件名：与more相似，但可以更好的翻页
	head 文件名：默认查看文件开头 10 行（head -n 打印开头到指定行）
	tail 文件名：默认查看文件从末尾往上 10 行
	（-n 打印末尾到指定行，-f 表示循环输出，文件有新内容时，会更新输出）
几个通配符：？代替单个字符 * 可以代替多个字符
文件行号，单词数，字节数：wc 命令
					 	-c：统计字节数
					 	-l：统计行数
					 	-w：统计单次数
文件权限：访问一个文件的人可能有三种：
			U User：文件所有者
			g Group：文件和文件目录的所欲在所在的组的用户
			o Others：其他用户
		两种用户：超级用户 root；普通用户
	  		超级用户：可以在Linux系统下做任何事情，不受限制，命令提示符是 #
	  		普通用户：在 Linux 下做有限的事情，提示符是 $
	  	权限修改命令：chmod
	  		读(r/4); 写(w/2); 执行(x/1)	  
```

![image-20201025155402075](D:/typora/appdata/image-20201025155402075.png)



##### 进程和系统相关命令

```
查看当前进程：ps -ef | grep "pid"
	D：不可中断状态，进程处于睡眠状态，不可中断
	R：暂停状态/跟踪状态
	S：就绪状态
	T：运行状态
	
	
执行退出：exit
查看当前全路径：pwd
查看端口号：netstat -anp | grep "端口号"
查看磁盘使用空间，空闲空间：df -hl
查看各分区使用情况：df -h
查看内存总量：grep MemTotal
查看空闲内存：grep MemFree
查看所有分区：fdisk -l
查看系统运行时间：uptime
```

【一面】

1.自我介绍

2.说一下你所理解的测试和开发的区别

3.了解测试的哪些知识

4.自动化测试了解哪些

5.如果给你一个指纹锁，从指纹，屏幕显示，存储，电池几方面来设计测试用例

6.给了一个矿泉水瓶子的需求，要求设计测试用例（这里考察判断需求是否合理，重点不在测试用例）

7.设计一个椭圆形瓶身，瓶盖有logo，瓶身有商标，容量是500ml的矿泉水瓶子的测试用例（这才是一个合理的需求）

8.有没有用过测试工具，会不会写脚本

9.测试的流程

10.软件开发的流程

11.测试在什么时候介入比较好

（面试官问的不多也没有很难，全程大多数时候都在指导我，如何有逻辑性的设计测试用例，如何更加严谨的设计测试用例，提了一些很好的建议）



【二面】

1.自我介绍

2.设计一个电梯的测试用例，思考一下

3.如何去设计电梯的测试用例（考察需求分析）-》这里面试官给我指导了很多没有思考到的地方

4.查看系统的命令

5.查看端口的命令

6.查看进程的命令

7.讲一下qq用的什么协议

8.TCP协议和UDP协议的区别

9.了不了解OOM，什么情况下使用出现OOM

（二面还是一样，面试官指导了很多关于以后软件测试需要做的事，以及需要具备的能力，以及思考的维度，说了很多很多，也很细致，感觉确实很受用）



【hr面】

1.自我介绍

2.家是哪里的，为什么要去别的城市找工作不留在陕西

3.最近有别的offer嘛，为什么没有去

4.薪资是多少，你的期望薪是多少（一定要让说数字）

5.为什么做测试

6.有没有对你帮助（影响）比较大的人，

7.对于盒子有什么建议，你觉得盒子的发展前景在哪里

8.父母的工作

9.自己最大的缺点

10.你有什么想问我的



一面：

1、自我介绍

2、你理解的测试工作是什么样子的

3、讲一讲你这个项目

4、假如说我现在需要一个水瓶，指着桌子上的农夫山泉，就拿这个来说吧，说你会怎么给工厂提需求

5、我刚说两句，面试官说，我打断一下，在这过程中，你有任何问题可以问我（当时没get到他想表达的点），说了我能想到的之后，他说，你怎么知道我想要一个什么样的水瓶，我只给了一个瓶子，你说的这些虽然都对了，但都是想象，我并没有告诉你，瓶子要什么颜色，什么花纹，多大，等等，所以我刚才有说，有任何问题可以问我（懂了。。。）

总之这道题就是考你提需求是否全面叭，跟测试用例是不一样的，以前被问到的都是写测试用例，第一次遇到提需求，有些懵。。。

6、跟开发人员意见不一致怎么解决

（其它的忘了，问的比较基础，而且，面试官有超耐心的跟你讲这些内容，可惜，我三秒钟记忆，说完就不太记得了。。。）

7、提一个问题



二面：

1、自我介绍

2、代码题，也可以就说说思路

找出1000以内所有的奇数，不要9

3、设计一个电梯的测试用例

这个题我从各个方面说了之后，他问那具体怎么测呢，比如说你这时间怎么测，还有如果电梯里发生火灾，你要怎么测，总之就是要问具体方法，这个我还真的有些懵，难道生一把火吗？？？？

4、问了MySQL里面一个简单的查询

5、问了关于Linux的几个命令：

查看端口的、怎么杀死一个进程、kill和kill -9的区别，还问了啥记不太清了

6、测试类工作你更偏向做啥，测试/测开？

7、还问了简历上的一些问题，忘记了。。。

8、有什么问题

（又是一次凉经，不过这个公司的运维还有一个面试官人挺好，很积极地问我们结果如何，我们说不清楚，一次一次地去帮我们查，还让我朋友转运维，哈哈哈）





## 项目详细

#### MVC



+ 核心功能/模块划分
  + 群聊，消息推送给每个在线用户
+ 主要流程
  + 点击消息发送按钮，客户端给服务器发送消息
  + 服务器收到消息，把消息加入到阻塞队列
  + 使用扫描线程，从阻塞队列中获取获取消息转送给在线用户



1> 接口1：建立 websocket 链接，传输消息的准备工作

+ 就不是 http 协议了 ws://[ip]:[port]/message/{userId} 每个登录中的用户，都需要有自己的连接，把连接之间使用 userId 区分

2> 接口2：发送/接受消息，为了简单把消息格式统一了

+ 创建一个数据结构，保存服务器收到的消息

  阻塞式队列：服务器接收到的消息就会放在这个消息队列中(生产者)

​       另外启动一个线程，让线程扫描队列，并把消息准发给其他在线客户(消费者)

+ 创建一个数据结构，保存在线用户列表，转发的时候要给所有的在线用户

  ​       (严格来讲应该把消息转发给所有关注了当前频道的用户，但是没有实现关注，就相当于直接所有用户都关注了所有频道，就是有消息无脑转发给所有用户就行)

  用 hash 表保存  key-- userId    value--Session对象

  (Websocket 内置的session，有用户建立了连接就会自动创建 session 对象)

  **使用哈希表优点：**

  就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。

  **原理：**

  其取值过程是:

  \1. 得到key
  \2. 通过hash函数得到hash值
  \3. 得到桶号(一般都为hash值对桶数求模)
  \4. 比较桶的内部元素是否与key相等，若都不相等，则没有找到。
  \5. 取出相等的记录的value。



用户上线(建立 websocket 连接)

```
@OnOpen
public void onOpen(@PathParam("userId") String userIdStr,Session session) {
	// 获取 userId
	this.userId = Integer.parseInt(userIdStr);
	System.out.println("建立连接："+userId);
	// 把该用户加入到在线用户列表中
	MessageCenter.getInstance().addOnlineUser(userId,session);
}
```

消息转发（服务器收到客户端发的消息，就会出触发 onMessage 函数，函数中调用 sendText 把数据返回给浏览器，浏览器收到服务器的响应之后就会触发 onmessage 函数从而打印收到的内容）

```
@OnMessage
public void onMessage(String request,Session session){
	// 解析 message 格式，收到的 request 对象应该是一个 json 字符串
	Message message = gson.fromJson(request,Message.class);
	// 填写消息的发送时间
	// 消息同步到消息中心
	// 消息写入数据库
}
```

用户下线

```
@onClose
public void onClose() {
	System.out.println("连接断开！"+userId);
	// 把用户从在线列表中删除
	MessageCenter.getInstance().delOnlineUser(userId);
}
```

为啥使用一个生产者消费者模型？

如果直接在 onMessage 方法中，收到消息立刻遍历在线用户列表转发消息，可以，但是不够好，为什么？

+ 如果消息数目少，无所谓
+ 如果消息多，短时间内，大量得到消息，服务器可能会被这样的请求峰值打卦，因为每次转发都是一个耗时的开销，如果消息数目多，在线用户数目多，onMesage 方法周转速率就慢，导致处理不过来，引入一个额外的存储消息队列，相当于一个缓冲区，可以削峰

![image-20200918090054323](D:/typora/appdata/image-20200918090054323.png)



轮询：浪费带宽资源，因为浏览器不断地向服务器发送 http 请求，而http请求可能包含比较长的头部，真正传输的数据可能只有一小部分，还有其实在实际生活场景中我们也不是每时每刻都回收到消息

WebSocket其实和http没有什么关系，只是为了兼容现有浏览器的握手规范，也就
是说他是http协议上的一种补充  。多了两个东西：

Upgrade：websoket

Connection：Upgrade

告诉服务器发送的是





### 小米

手机相机怎么测试？

那实际上手机相机要和很多有交互，比如麦克风、耳机(有线、蓝牙)、触屏、自拍杆啊这些点其实很多。那最基础的来看，手机相机就是拍照和录像两个功能，我可能会从这两个点入手设计测试点。

```
功能上考虑：
	锁屏界面正常进入、退出拍照
	解锁后正常进入、退出
	其他软件跳转进入、退出
	拍照时比例是否可选
	拍照时滤镜的切换，不同模式是否需要下载(说到下载了又设计到下次访问是否重新下载)
	拍照模式的切换，连拍、延时拍摄
	拍照后是自动保存还是需要手动点击保存
	如果需手动保存当下是否支持编辑功能（编辑功能可以展开、涉及拍照结束后停留页面）
	拍照打开、关闭闪光灯的情况
	拍照音效能否关闭、切换
	拍照切换到录像、或是否支持直接到录像（要有图标的变化，计时显示）
	录像点击开始是否有音效、结束是否有
	录制时长（超过时长自动停止？如果此时缓存的内存满了？）
	录制完成后是自动保存还是需要手动（涉及一次录制后停留的位置）
	还有录制能否选择清晰度这样的问题
	前面说到拍照后有编辑，一般也有发送，也涉及到别的，
	还有相册列表，拍照和视频的顺序和分类
	
```

手机测试：

```
UI 体验
	主题、图标、锁屏、手机比例，屏幕比例
	本地研发客户端：音乐、相机
	图标处理
	界面布局
	界面操作和标题
	按键位置，返回键和
功能完整
容错机制
交互体验
兼容性
性能
```







电梯怎么测试？



生成 10 个随机数，怎么快速找到最大的数？



进入部门的挑战？怎么证明你能够胜任这份工作



瀑布模型，w模型、v模型



你对小米的看法



你觉得这是 bug，开发不觉得？

```
这个要从我作为测试和开发两个角度去考虑
	测试认为是，自己需要反复确认拿出文档、需求依据，或者是不是因为需求没有确定好，确认这个是不是要改，还有如果这中概率比较小，那尽可能说出bug依据，被用户发现会怎样，和开发经理和测试经理确认
	开发认为不是可能是我测试没描述清楚或者提供的bug很难难重现、与需求不一致，hu欧洲有一定的争议，可能要开 bug 评审会
```

对测试的了解



如何使用java创建一个文件，如果有同名文件怎么办？



数据库查看有多少行用什么                              



测试和产品的区别？为什么想做测试？



测试淘宝购物车，哪些步骤？



网页输入一个url解析过程



测试计划要写那些内容



小程序如何考虑测试



linux查IP地址（ip addr）



tcp与udp区别



IPV4和IPV6区别



session和cookie的区别



http和https的区别？



get和post的区别？



tcp的三次握手？为什么不是两次？



你所熟悉的linux命令？



给一个表查询年龄前十的同学？



在浏览器请求数据，网址都用了那些协议，如何请求到信息？



索引的类型有哪些能解释一下吗？



## HR

+ 为什么选择xxx

其实之前就听过XXX，主要做的事，这是很前沿，发展前景很好的，尤其是 5G 到来之后，海康：音视屏编解码，云计算，大数据，深度学习，流媒体网络传输，这些本来都是很前沿的技术，随着5G 的到来，这些技术会催生出很好的前景



+ 5G

最直观感受到的是速度，平均下载速率在700mbps，上传在80mbps左右，几乎是 4 G 速度的十倍，极大优化网络体验，保存在本地看和把视频保存在云端下载看几乎没区别，可是4G也能满足速度，感觉有点杀鸡用牛刀。4G 带来了什么，移动支付(网络+二维码)，上传速度可以视频直播，全民皆可直播的时代来临，4G 催生了甚多服务，外卖打车。而 5G 就会伴随 VR 和 AR 的普及化，之前 VR 与 AR 用户体验上活出现头晕目眩等大多是网络延迟造成， VR 实现体育赛事和演唱会等大型场景的现场直播。万物互联、超低时延

+ 工作地点，调剂回那里

很多地方没去过，如果能工作在那里都行，比如杭州环境美，能在那里生活很好

+ 考研

也是一个很好的选择，可以做一些深度学习，但每个人选择不一样，而且在我的认知里，对于 IT 行业,一部分领域的工作与结合实际的商业项目对自己的技术提升更大，比如我现在选择的测试，他需要经验的积累，而这种积累就需要实际项目中体会和发现。

+ 技术素养 + 分析问题解决问题的能力 + 学习能力 + 沟通能力 + 产品的理解深度
+ 转语言

我主要使用的是 Java，但语言是相通的，不会像初学那样很大的时间成本，代码之外的重要的是学习能力和方式达到高效完成业务要求，这个会比较重要。

+ 职业规划

暂时没有给自己制定非常长远和固化的规划，我选择的是测试，而测试应该是非常需要经验才能做到资深的，所以我短期内还是希望能结合公司的业务，积累测试经验，提升技术实力，承担更多业务线。

+ 加班

作为一个新人，其实应该花时间熟悉公司的业务，学习技术，工作时间多长不重要，就我自己还是希望刚参加工作多努力付出，付出是有回报的

+ 薪资

我对工资没有硬性要求。我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多

+ 自我评价

适应能力强，有责任心和做事有始终，正能量，抗压，随和，换位思考，冷静理智

+ 优、却点

优点：自我感觉的话，可能因为有过志愿讲解的经历，所以感觉比较能换位思考，跟人沟通方面会好一点，性格也随和。也参与过团队项目，所以适应力责任心这里还可以，

缺点：其实我对那些团队秩序很差的情况包容度不高，我比较能吃吧，每次宿舍一起吃饭我都是最后清扫战场那个
压力：压力也很多，可能对我来讲没有一个长时间的高压状态，比如高考学不懂的时候，可能某个瞬间会让我觉得挺大压力的，但是跟老师沟通一下，放空思考一下就继续向前了。有时候跟大家聊也就是秋招和考研的朋友也会说这个，那能力和野心匹配吧
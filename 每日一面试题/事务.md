## 事务

**问题描述**	

​	谈谈你对事务的理解

---

**整体思路**

​	![Snipaste_2020-05-11_17-36-20](.\Images\Snipaste_2020-05-11_17-36-20.png)

---

##### 事务的背景

​	生活中有个例子，如张三有现在元，李四有1000元，张三向李四转账2000元，那这就要分成两步来执行

1. 张三的账户-2000元
2. 李四的账户+2000元

可如果现在第一步执行完，突然断网了；突然数据库崩了；突然停电了...那这张三岂不是很亏...

可如果有事务，事务执行到第一步结束时被终止就会触发事务回滚(rollback)，第一步又会重新打回去，相当于又把张三扣的钱又加回去

总的来说：**事务就是一组”同生共死“操作的集合**

---

##### 事务的特性

1. **原子性**：一个事务是个不可分割的单位，要通过都通过，要不做都不做
2. **一致性**：事务执行前后，数据要有合理性，如张三和李四的资产和为6000元，切金额不能为负值
3. **持久性**：事务一旦被提交，那效果就是永久的，不会回滚回去，无论出现其他啥事务，也不会影响刚才原事务。
4. **隔离性**：多个事务**并发**执行，各个事务的内部操作都互不影响

---

##### 关于隔离性

---

###### 先来了解**并发**和**并行**

​	**并发**：微观上是串行执行的，但宏观上感觉好像都是”同时“执行

​	**并行**：微观宏观都是串行执行的

> 举个栗子：一个CPU上运行着QQ，还运行着微信，宏观上看起来好像是同时运行的，但微观上这个CPU是执行QQ一段时间后又执行微信一段时间，整个CPU只要切换速度够快，在宏观上就看起来像是“同时”执行，这就是并发
>
> 而如果是两台CPU，CPU1运行着QQ，CPU2运行着微信，这个在微观上QQ和微信都一直是在运行的，这就是并行

---

###### 并发带来的3个问题

​	并发一直是编程的难点，甚至由于并发编程太难了，有的语言压根不支持并发，或者搞一个“假的并发”

​	比如这几年新兴起的python，他虽然标准库中有”创建线程“的API，但他创建的线程仍是假的，仍然是串行执行的(GIL锁)；再比如这几年为啥GO火了，就是因为GO处理并发贼简单.有点像Java的JDBC,你看C++的馋不馋~~~

​	并发操作可能会带来的3种问题

​	 	1. **脏读**	读到了假数据

​				举2个例子吧

* 老师正在上网课敲代码，完了把代码发群里，学生也跟着敲代码，现在老师敲了个Student类,里面有个属性name，学生看见有个Student类，类里有个name，然后学生就敲自己的去了，结果老师后来把name属性删除了，然后发到群里，但学生不知道，测试的时候出了问题。
* 张三有5000，李四有1000，现在张三向李四转帐两次1000，原本过程应该是![1588854774895](.\Images\1588854774895.png)

可现在过程成了在第一步时就到线程2，读张三的账户就读错了

![1588854979035](.\Images\1588854979035.png)

**解决思路：**此时我们对隔离性并没有要求，于是就产生了脏读，为了避免脏读，在老师写代码操作时进行**”加锁“**，学生此时不能看到代码。(这就提高了隔离性，但也就降低了并发性)

​	2. **不可重复读**	一个事务中两次读到的结果不一样

​		还是说之前老师发代码那个例子吧，现在老师把代码发到群里后，学生就开始读,老师觉得代码不合适，然后就修改代码再提交，学生就发现两次代码不一样

![1588855548889](.\Images\1588855548889.png)

**解决思路**：为了避免不可重复读，在学生读操作时进行加锁，老师不能改Student类（隔离性进一步提高，并发性进一步降低）

3. **幻读**	同一个事务多次查询返回的结果集不同

​		刚才对学生读操作加锁时只是让老师不准写Student类，现在老师不写Student类，写Teacher类了，然后提交，学生读就又不一样了

![1588856382847](.\Images\1588856382847.png)

**解决思路**：你把这搞成两个事务啊，“串行化”——此时这已经就是串行了，没并发性了

![1588856678852](.\Images\1588856678852.png)

---

###### MySQL中的事务隔离级别

​	(手动设置这个级别,调节并发性和隔离性)

1. read uncommitted允许读取未提交的数据;并行最大,隔离最低会产生脏读问题.

2. read committed,只允许读取提交的数据，相当于写加锁,并行降低了- -点隔离提高了- -点能够避免脏读问题,但是存在不可重复读

3. repeatable read,读写的时候都加锁，此时并行进一步降低, 隔离进一步提高 了,能够避免不可重复度问题,存在幻读问题(默认隔离级别)

4. serializable,严格串行执行，隔离程度最高,并行程度最低，能够避免幻读问题.
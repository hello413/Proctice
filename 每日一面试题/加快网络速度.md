### 加快网络速度——TCP优化

**问题描述**

​		 为什么这么多年来网速越变越快，TCP协议一直没怎么变化呢？ 

---

 **提升网速**的不二法门就是... 买宽带~  

---

##### 常见的TCP延时事务

* 3次握手4次挥手
* 延时确认
* nagle算法
* slow-start
* 端口耗尽

---

这儿3次握手4次挥手就简单说下

![Snipaste_2020-05-22_11-13-28](Images\Snipaste_2020-05-22_11-13-28.png)



![Snipaste_2020-05-22_12-16-15](Images\Snipaste_2020-05-22_12-16-15.png)

这都要消耗时间，具体就不细说了，看图很明白

---

##### 延时确认

 		当你在进行网络数据传输, 成功发送数据包时, 服务器会给你返回一个ACK进行确认。  但是为了防止网络的堵塞，通常，服务器在接收该数据时，会对ACK进行延时, 如果在一定时间内(通常为200ms), 有另外的数据来源时,  则会将2次ACK包一起发送，减少宽带. 

---

##### nagle算法延时

​		 这是nagle 创建的一个算法，和延迟确认一样也是用来解决网络堵塞问题. 不过，他针对的是**Sender一端**. 众所周知的TCP的大小有40  bytes. 如果你的数据包内容才1B的话,  这样传输的价值就非常小了.所以，聪明的nagle想了想,这样不行，得让小数据包在缓存里面待一段时间，等数据多了再一起发送，如果是在没有其他数据了, 超过nagle算法设置的时延后,那就只能单独发送了. 

###### nagle的缺陷

​	他针对的**小数据包**， 所以对于小包的影响很大. 但如果是一个小数据的话就不值得了，比如: 你使用HTTP只是发送GET请求,要求数据库进行相关的取操作,而返回的数据很小. 那么，这时候nagle会让你欲哭无泪~ 

###### 解决缺陷

​		可通过改变确认时延的值

----

##### slow-start 算法 

>  slow-start 是为了解决网络延迟而被设计出来的一个算法，逐步增加数据包的发送量，直到发送端和接收端能够承载的最大值为止. 

![Snipaste_2020-05-22_12-16-15](Images\Snipaste_2020-05-22_21-32-21.png)

这个细说也挺多的，可以去看看相关博客

这儿只是简单介绍	(面试还是弄清其原理和实现比较好)

###### 实现(其实看图比看文档更清楚)

- 在首次发送信息时, Sender 会初始化一个包, 并且该包里面包含了一个比较小的 **堵塞窗口**(其实就是表明窗口的容载量--bytes). 他的大小是由 MSS 决定的.比如,我们的MSS为1460B, 那么我们初始化的congeston window就可以为2920B. 即,相当于发送了2个小分组. (不理解，见window size)
- 接受者接受到包之后, 会返回一个ACK包，并附上 receiver's window size(通常,会比sender发送过来的大). 如果, receiver 没有响应， 那么sender 就知道自己 的包太大了, 然后会自行改小 然后再发送.
- sender接受到receiver 的 ACK后，此时就在上一次发送的基础上额外加上一倍的MSS. 即,  上一次，我发送了2个MSS大小的包, 那么此时,会接受到两次ACK确认，接收到之后，我就可以增大window size,  向receiver额外再发送一倍---4个MSS大小(2920 + 1460 + 1460). 如此往复，直到两边的window size  到达上限之后，那么slow start 就已经完成了.

---

##### 端口耗尽

4次挥手时，在双方发送一次FIN包之后，还需要经过TIME_WAIT的2MSL时延之后，才可以正式宣告结束  端口的利用才有可能被释放 